{
    "version": "https://jsonfeed.org/version/1",
    "title": "DXZ",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/01/21/Linux%20interview%20summary/",
            "url": "http://example.com/2021/01/21/Linux%20interview%20summary/",
            "title": "Linux interview summary",
            "date_published": "2021-01-21T09:30:38.267Z",
            "content_html": "<h2 id=\"常用指令\"><a class=\"markdownIt-Anchor\" href=\"#常用指令\">#</a> 常用指令</h2>\n<p>ls　　        显示文件或目录<br>\n - l           列出文件详细信息 l (list)<br>\n-a          列出当前目录下所有文件及目录，包括隐藏的 a (all)<br>\n mkdir         创建目录<br>\n - p           创建目录，若无父目录，则创建 p (parent)<br>\n cd               切换目录<br>\n touch          创建空文件<br>\n echo            创建带有内容的文件。<br>\ncat              查看文件内容<br>\n cp                拷贝<br>\n mv               移动或重命名<br>\n rm               删除文件<br>\n - r            递归删除，可删除子目录及文件<br>\n - f            强制删除<br>\n find              在文件系统中搜索某文件<br>\n wc                统计文本中行数、字数、字符数<br>\n grep             在文本文件中查找某个字符串<br>\n rmdir           删除空目录<br>\n tree             树形结构显示目录，需要安装 tree 包<br>\n pwd              显示当前目录<br>\n ln                  创建链接文件<br>\n more、less  分页显示文本文件内容<br>\n head、tail    显示文件头、尾内容<br>\n ctrl+alt+F1  命令行全屏模式</p>\n<h2 id=\"系统管理命令\"><a class=\"markdownIt-Anchor\" href=\"#系统管理命令\">#</a> 系统管理命令</h2>\n<p>stat              显示指定文件的详细信息，比 ls 更详细<br>\n who               显示在线登陆用户<br>\n whoami          显示当前操作用户<br>\n hostname      显示主机名<br>\n uname           显示系统信息<br>\n top                动态显示当前耗费资源最多进程信息<br>\n ps                  显示瞬间进程状态 ps -aux<br>\ndu                  查看目录大小 du -h /home 带有单位显示目录信息<br>\n df                  查看磁盘大小 df -h 带有单位显示磁盘信息<br>\n ifconfig          查看网络情况<br>\n ping                测试网络连通<br>\n netstat          显示网络状态信息<br>\n man                命令不会用了，找男人  如：man ls<br>\nclear              清屏<br>\n alias               对命令重命名 如：alias showmeit=“ps -aux” ，另外解除使用 unaliax showmeit<br>\nkill                 杀死进程，可以先用 ps 或 top 命令查看进程的 id，然后再用 kill 命令杀死进程。</p>\n<h2 id=\"打包压缩相关命令\"><a class=\"markdownIt-Anchor\" href=\"#打包压缩相关命令\">#</a> 打包压缩相关命令</h2>\n<p>gzip：<br>\nbzip2：<br>\ntar:                打包压缩<br>\n - c              归档文件<br>\n - x              压缩文件<br>\n - z              gzip 压缩文件<br>\n - j              bzip2 压缩文件<br>\n - v              显示压缩或解压缩过程 v (view)<br>\n-f              使用档名<br>\n例：<br>\ntar -cvf /home/abc.tar/home/abc              只打包，不压缩<br>\n tar -zcvf /home/abc.tar.gz/home/abc        打包，并用 gzip 压缩<br>\n tar -jcvf /home/abc.tar.bz2 /home/abc      打包，并用 bzip2 压缩<br>\n当然，如果想解压缩，就直接替换上面的命令  tar -cvf  /tar -zcvf  /tar -jcvf 中的 “c” 换成 “x” 就可以了。</p>\n<h2 id=\"关机重启机器\"><a class=\"markdownIt-Anchor\" href=\"#关机重启机器\">#</a> 关机 / 重启机器</h2>\n<p>shutdown<br>\n-r             关机重启<br>\n - h             关机不重启<br>\n now          立刻关机<br>\n halt               关机<br>\n reboot          重启</p>\n<h2 id=\"linux管道\"><a class=\"markdownIt-Anchor\" href=\"#linux管道\">#</a> Linux 管道</h2>\n<p>将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。<br>\n例：grep -r “close” /home/* | more       在 home 目录下所有文件中查找，包括 close 的文件，并分页输出。</p>\n<h2 id=\"linux软件包管理\"><a class=\"markdownIt-Anchor\" href=\"#linux软件包管理\">#</a> Linux 软件包管理</h2>\n<p>dpkg (Debian Package) 管理工具，软件包名以.deb 后缀。这种方法适合系统不能联网的情况下。<br>\n比如安装 tree 命令的安装包，先将 tree.deb 传到 Linux 系统中。再使用如下命令安装。<br>\nsudo dpkg -i tree_1.5.3-1_i386.deb         安装软件<br>\n sudo dpkg -r tree                                     卸载软件<br>\n注：将 tree.deb 传到 Linux 系统中，有多种方式。VMwareTool，使用挂载方式；使用 winSCP 工具等；<br>\nAPT（Advanced Packaging Tool）高级软件工具。这种方法适合系统能够连接互联网的情况。</p>\n<p>依然以 tree 为例<br>\n sudo apt-get install tree                         安装 tree<br>\nsudo apt-get remove tree                       卸载 tree<br>\nsudo apt-get update                                 更新软件<br>\n sudo apt-get upgrade</p>\n<p>将.rpm 文件转为.deb 文件<br>\n.rpm 为 RedHat 使用的软件格式。在 Ubuntu 下不能直接使用，所以需要转换一下。<br>\nsudo alien abc.rpm</p>\n<h2 id=\"vim使用\"><a class=\"markdownIt-Anchor\" href=\"#vim使用\">#</a> vim 使用</h2>\n<p>vim 三种模式：命令模式、插入模式、编辑模式。使用 ESC 或 i 或：来切换模式。<br>\n命令模式下：<br>\n:q                      退出<br>\n:q!                     强制退出<br>\n:wq                   保存并退出<br>\n:set number     显示行号<br>\n:set nonumber  隐藏行号<br>\n /apache            在文档中查找 apache 按 n 跳到下一个，shift+n 上一个<br>\n yyp                   复制光标所在行，并粘贴<br>\n h (左移一个字符←)、j (下一行↓)、k (上一行↑)、l (右移一个字符→)</p>\n<h2 id=\"用户及用户组管理\"><a class=\"markdownIt-Anchor\" href=\"#用户及用户组管理\">#</a> 用户及用户组管理</h2>\n<p>/etc/passwd    存储用户账号<br>\n /etc/group       存储组账号<br>\n /etc/shadow    存储用户账号的密码<br>\n /etc/gshadow  存储用户组账号的密码<br>\n useradd 用户名<br>\n userdel 用户名<br>\n adduser 用户名<br>\n groupadd 组名<br>\n groupdel 组名<br>\n passwd root     给 root 设置密码<br>\n su root<br>\nsu - root<br>\n/etc/profile     系统环境变量<br>\n bash_profile     用户环境变量<br>\n.bashrc              用户环境变量<br>\n su user              切换用户，加载配置文件.bashrc<br>\nsu - user            切换用户，加载配置文件 /etc/profile ，加载 bash_profile</p>\n<h2 id=\"更改文件的用户及用户组\"><a class=\"markdownIt-Anchor\" href=\"#更改文件的用户及用户组\">#</a> 更改文件的用户及用户组</h2>\n<p>sudo chown [-R] owner[:group] {File|Directory}<br>\n 例如：还以 jdk-7u21-linux-i586.tar.gz 为例。属于用户 hadoop，组 hadoop<br>\n 要想切换此文件所属的用户及组。可以使用命令。<br>\nsudo chown root:root jdk-7u21-linux-i586.tar.gz</p>\n<h2 id=\"绝对路径用什么符号表示绝对路径用什么符号表示当前目录-上层目录用什么表示主目录用什么表示-切换目录用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#绝对路径用什么符号表示绝对路径用什么符号表示当前目录-上层目录用什么表示主目录用什么表示-切换目录用什么命令\">#</a> 绝对路径用什么符号表示绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示？切换目录用什么命令？</h2>\n<p>绝对路径： 如 /etc/init.d<br>\n 当前目录和上层目录： ./  …/<br>\n 主目录： ~/<br>\n 切换目录： cd</p>\n<h2 id=\"怎么查看当前进程怎么执行退出怎么查看当前路径\"><a class=\"markdownIt-Anchor\" href=\"#怎么查看当前进程怎么执行退出怎么查看当前路径\">#</a> 怎么查看当前进程？怎么执行退出？怎么查看当前路径？</h2>\n<p>查看当前进程： ps<br>\n 执行退出： exit<br>\n 查看当前路径： pwd</p>\n<h2 id=\"怎么清屏怎么退出当前命令怎么执行睡眠怎么查看当前用户-id查看指定帮助用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#怎么清屏怎么退出当前命令怎么执行睡眠怎么查看当前用户-id查看指定帮助用什么命令\">#</a> 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？</h2>\n<p>清屏： clear<br>\n 退出当前命令： ctrl+c 彻底退出<br>\n执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台<br>\n查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名<br>\n查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser --help 这个告诉你一些常用参数； info adduesr；</p>\n<h2 id=\"ls-命令执行什么功能-可以带哪些参数有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#ls-命令执行什么功能-可以带哪些参数有什么区别\">#</a> Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？</h2>\n<p>ls 执行的功能： 列出指定目录中的目录，以及文件<br>\n哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等</p>\n<h2 id=\"建立软链接快捷方式以及硬链接的命令\"><a class=\"markdownIt-Anchor\" href=\"#建立软链接快捷方式以及硬链接的命令\">#</a> 建立软链接 (快捷方式)，以及硬链接的命令。</h2>\n<p>软链接： ln -s slink source<br>\n 硬链接： ln link source</p>\n<h2 id=\"目录创建用什么命令创建文件用什么命令复制文件用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#目录创建用什么命令创建文件用什么命令复制文件用什么命令\">#</a> 目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？</h2>\n<p>创建目录： mkdir<br>\n 创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件<br>\n复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？<br>\n文件权限修改： chmod<br>\n 格式如下：<br>\nchmodu+xfile 给 file 的属主增加执行权限  chmod 751 file 给 file 的属主分配读、写、执行 (7) 的权限，给 file 的所在组分配读、执行 (5) 的权限，给其他用户分配执行 (1) 的权限<br>\n chmodu=rwx,g=rx,o=xfile 上例的另一种形式 chmod =r file 为所有用户分配读权限<br>\n chmod444file 同上例 chmod a-wx,a+r file 同上例<br>\n $ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限</p>\n<h2 id=\"查看文件内容有哪些命令可以使用\"><a class=\"markdownIt-Anchor\" href=\"#查看文件内容有哪些命令可以使用\">#</a> 查看文件内容有哪些命令可以使用？</h2>\n<p>vi 文件名 #编辑方式查看，可修改<br>\n cat 文件名 #显示全部文件内容<br>\n more 文件名 #分页显示文件内容<br>\n less 文件名 #与 more 相似，更好的是可以往前翻页<br>\n tail 文件名 #仅查看尾部，还可以指定行数<br>\n head 文件名 #仅查看头部，还可以指定行数</p>\n<h2 id=\"随意写文件命令怎么向屏幕输出带空格的字符串比如hello-world\"><a class=\"markdownIt-Anchor\" href=\"#随意写文件命令怎么向屏幕输出带空格的字符串比如hello-world\">#</a> 随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?</h2>\n<p>写文件命令：vi<br>\n 向屏幕输出带空格的字符串:echo hello world</p>\n<h2 id=\"终端是哪个文件夹下的哪个文件黑洞文件是哪个文件夹下的哪个命令\"><a class=\"markdownIt-Anchor\" href=\"#终端是哪个文件夹下的哪个文件黑洞文件是哪个文件夹下的哪个命令\">#</a> 终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？</h2>\n<p>终端  /dev/tty<br>\n 黑洞文件  /dev/null</p>\n<h2 id=\"移动文件用哪个命令改名用哪个命令\"><a class=\"markdownIt-Anchor\" href=\"#移动文件用哪个命令改名用哪个命令\">#</a> 移动文件用哪个命令？改名用哪个命令？</h2>\n<p>mv mv</p>\n<h2 id=\"复制文件用哪个命令如果需要连同文件夹一块复制呢如果需要有提示功能呢\"><a class=\"markdownIt-Anchor\" href=\"#复制文件用哪个命令如果需要连同文件夹一块复制呢如果需要有提示功能呢\">#</a> 复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？</h2>\n<p>cp cp -r  ？？？？</p>\n<h2 id=\"删除文件用哪个命令如果需要连目录及目录下文件一块删除呢删除空文件夹用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#删除文件用哪个命令如果需要连目录及目录下文件一块删除呢删除空文件夹用什么命令\">#</a> 删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</h2>\n<p>rm rm -r rmdir</p>\n<h2 id=\"linux-下命令有哪几种可使用的通配符分别代表什么含义\"><a class=\"markdownIt-Anchor\" href=\"#linux-下命令有哪几种可使用的通配符分别代表什么含义\">#</a> Linux 下命令有哪几种可使用的通配符？分别代表什么含义？</h2>\n<p>“？” 可替代单个字符。<br>\n“*” 可替代任意多个字符。<br>\n方括号 “[charset]” 可替代 charset 集中的任何单个字符，如 [a-z]，[abABC]</p>\n<h2 id=\"对一个文件的内容进行统计用什么命令行号-单词数-字节数\"><a class=\"markdownIt-Anchor\" href=\"#对一个文件的内容进行统计用什么命令行号-单词数-字节数\">#</a> 对一个文件的内容进行统计用什么命令？(行号、单词数、字节数)</h2>\n<p>wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。</p>\n<h2 id=\"grep-命令有什么用-如何忽略大小写-如何查找不含该串的行\"><a class=\"markdownIt-Anchor\" href=\"#grep-命令有什么用-如何忽略大小写-如何查找不含该串的行\">#</a> Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行？</h2>\n<p>是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。<br>\ngrep [stringSTRING] filename grep [^string] filename</p>\n<h2 id=\"linux-中进程有哪几种状态在-ps-显示出来的信息中分别用什么符号表示的\"><a class=\"markdownIt-Anchor\" href=\"#linux-中进程有哪几种状态在-ps-显示出来的信息中分别用什么符号表示的\">#</a> Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？</h2>\n<p>1）、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。<br>\n（2）、暂停状态 / 跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态；当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。<br>\n“正在被跟踪” 指的是进程暂停下来，等待跟踪它的进程对它进行操作。<br>\n（3）、就绪状态：在 run_queue 队列里的状态<br>\n（4）、运行状态：在 run_queue 队列里的状态<br>\n（5）、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起<br>\n（6）、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉<br>\n（7）、退出状态<br>\n D 不可中断 Uninterruptible（usually IO）<br>\nR 正在运行，或在队列中的进程<br>\n S 处于休眠状态<br>\n T 停止或被追踪<br>\n Z 僵尸进程<br>\n W 进入内存交换（从内核 2.6 开始无效）<br>\nX 死掉的进程</p>\n<h2 id=\"怎么使一个命令在后台运行\"><a class=\"markdownIt-Anchor\" href=\"#怎么使一个命令在后台运行\">#</a> 怎么使一个命令在后台运行？</h2>\n<p>一般都是使用 &amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)</p>\n<h2 id=\"利用-ps-怎么显示所有的进程-怎么利用-ps-查看指定进程的信息\"><a class=\"markdownIt-Anchor\" href=\"#利用-ps-怎么显示所有的进程-怎么利用-ps-查看指定进程的信息\">#</a> 利用 ps 怎么显示所有的进程？怎么利用 ps 查看指定进程的信息？</h2>\n<p>ps -ef (system v 输出)<br>\n ps -aux bsd 格式输出<br>\n ps -ef | grep pid</p>\n<h2 id=\"专门用来查看后台任务的是哪个命令\"><a class=\"markdownIt-Anchor\" href=\"#专门用来查看后台任务的是哪个命令\">#</a> 专门用来查看后台任务的是哪个命令？</h2>\n<p>job -l</p>\n<h2 id=\"把后台任务调到前台执行使用什么命令把停下的后台任务在后台执行起来用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#把后台任务调到前台执行使用什么命令把停下的后台任务在后台执行起来用什么命令\">#</a> 把后台任务调到前台执行使用什么命令？把停下的后台任务在后台执行起来用什么命令？</h2>\n<p>把后台任务调到前台执行 fg<br>\n 把停下的后台任务在后台执行起来 bg</p>\n<p>## 终止进程用什么命令？带什么参数？<br>\nkill [-s &lt; 信息名称或编号&gt;][程序] 或 kill [-l &lt; 信息编号 &gt;]<br>\nkill-9 pid</p>\n<h2 id=\"怎么查看系统支持的所有信号\"><a class=\"markdownIt-Anchor\" href=\"#怎么查看系统支持的所有信号\">#</a> 怎么查看系统支持的所有信号？</h2>\n<p>kill -l</p>\n<h2 id=\"搜索文件用什么命令-格式是怎么样的\"><a class=\"markdownIt-Anchor\" href=\"#搜索文件用什么命令-格式是怎么样的\">#</a> 搜索文件用什么命令？格式是怎么样的？</h2>\n<p>find &lt;指定目录&gt; &lt; 指定条件 &gt; &lt; 指定动作 &gt;<br>\nwhereis 加参数与文件名<br>\n locate 只加文件名<br>\n find 直接搜索磁盘，较慢。<br>\nfind / -name “string*”</p>\n<h2 id=\"查看当前谁在使用该主机用什么命令-查找自己所在的终端信息用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#查看当前谁在使用该主机用什么命令-查找自己所在的终端信息用什么命令\">#</a> 查看当前谁在使用该主机用什么命令？查找自己所在的终端信息用什么命令？</h2>\n<p>查找自己所在的终端信息：who am i<br>\n 查看当前谁在使用该主机：who</p>\n<h2 id=\"查看用过的命令列表使用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#查看用过的命令列表使用什么命令\">#</a> 查看用过的命令列表使用什么命令？</h2>\n<p>history</p>\n<h2 id=\"查看磁盘使用空间使用什么命令-空闲空间呢\"><a class=\"markdownIt-Anchor\" href=\"#查看磁盘使用空间使用什么命令-空闲空间呢\">#</a> 查看磁盘使用空间使用什么命令？ 空闲空间呢？</h2>\n<p>df -hl<br>\n 文件系统 容量 已用 可用 已用 % 挂载点<br>\n Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% /<br>\n/dev/hda1 494M 19M 450M 4% /boot</p>\n<h2 id=\"查看网络是否连通使用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#查看网络是否连通使用什么命令\">#</a> 查看网络是否连通使用什么命令？</h2>\n<p>netstat</p>\n<h2 id=\"查看-ip-地址及接口信息使用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#查看-ip-地址及接口信息使用什么命令\">#</a> 查看 ip 地址及接口信息使用什么命令？</h2>\n<p>ifconfig</p>\n<h2 id=\"查看各类环境变量用什么命令\"><a class=\"markdownIt-Anchor\" href=\"#查看各类环境变量用什么命令\">#</a> 查看各类环境变量用什么命令？</h2>\n<p>查看所有 env<br>\n 查看某个，如 home： env $HOME</p>\n<h2 id=\"指定命令提示符是通过什么命令\"><a class=\"markdownIt-Anchor\" href=\"#指定命令提示符是通过什么命令\">#</a> 指定命令提示符是通过什么命令？</h2>\n<p>\\u：显示当前用户账号<br>\n \\h：显示当前主机名<br>\n \\W：只显示当前路径最后一个目录<br>\n \\w：显示当前绝对路径（当前用户目录会以～代替）<br>\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>P</mi><mi>W</mi><mi>D</mi><mtext>：显示当前全路径</mtext></mrow><annotation encoding=\"application/x-tex\">PWD：显示当前全路径\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">显</span><span class=\"mord cjk_fallback\">示</span><span class=\"mord cjk_fallback\">当</span><span class=\"mord cjk_fallback\">前</span><span class=\"mord cjk_fallback\">全</span><span class=\"mord cjk_fallback\">路</span><span class=\"mord cjk_fallback\">径</span></span></span></span>：显示命令行’'或者’#'符号\n\\#：下达的第几个命令\n\\d：代表日期，格式为week day month date，例如：\"MonAug1\"\n\\t：显示时间为24小时格式，如：HH：MM：SS\n\\T：显示时间为12小时格式\n\\A：显示时间为24小时格式：HH：MM\n\\v：BASH的版本信息 如export PS1=’[\\u@\\h\\w\\#]‘</p>\n<h2 id=\"查找命令的可执行文件是去哪查找的-怎么对其进行设置及添加\"><a class=\"markdownIt-Anchor\" href=\"#查找命令的可执行文件是去哪查找的-怎么对其进行设置及添加\">#</a> 查找命令的可执行文件是去哪查找的？怎么对其进行设置及添加？</h2>\n<p>whereis [-bfmsu][-B &lt; 目录 &gt;…][-M &lt; 目录 &gt;…][-S &lt; 目录 &gt;…][文件…]<br>\n 补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。<br>\n-b   只查找二进制文件。<br>\n-B &lt;目录&gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。<br>\n-m   只查找说明文件。<br>\n-M &lt;目录&gt; 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。<br>\n-S &lt;目录&gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。<br>\nwhich 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。<br>\n-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。<br>\n-p 与 - n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。<br>\n-V   显示版本信息</p>\n<h2 id=\"对命令进行取别名\"><a class=\"markdownIt-Anchor\" href=\"#对命令进行取别名\">#</a> 对命令进行取别名？</h2>\n<p>alias la=‘ls -a’</p>\n<h2 id=\"du-和-df-的定义以及区别\"><a class=\"markdownIt-Anchor\" href=\"#du-和-df-的定义以及区别\">#</a> du 和 df 的定义，以及区别？</h2>\n<p>du 显示目录或文件的大小<br>\n df 显示每个 &lt;文件&gt; 所在的文件系统的信息，默认是显示所有文件系统。<br>\n（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。）<br>\ndu 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。<br>\ndf 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。</p>\n<h2 id=\"awk-详解\"><a class=\"markdownIt-Anchor\" href=\"#awk-详解\">#</a> awk 详解。</h2>\n<p>awk ‘{pattern + action}’ {filenames}<br>\n#cat /etc/passwd |awk -F ‘:’ ‘{print 1&quot;\\t&quot;7}’ //-F 的意思是以’:' 分隔 root /bin/bash<br>\ndaemon /bin/sh 搜索 /etc/passwd 有 root 关键字的所有行<br>\n #awk -F: ‘/root/’ /etc/passwd root❌0:0:root:/root:/bin/bash</p>\n<h2 id=\"给命令绑定一个宏或者按键的时候应该怎么做呢\"><a class=\"markdownIt-Anchor\" href=\"#给命令绑定一个宏或者按键的时候应该怎么做呢\">#</a> 给命令绑定一个宏或者按键的时候，应该怎么做呢？</h2>\n<p>可以使用 bind 命令，bind 可以很方便地在 shell 中实现宏或按键的绑定。<br>\n在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。<br>\n比如获取 F12 的字符序列获取方法如下：先按下 Ctrl+V, 然后按下 F12 . 我们就可以得到 F12 的字符序列 ^[[24~。<br>\n接着使用 bind 进行绑定。<br>\n[root@localhost ~]# bind ‘”\\e[24~&quot;:“date”’<br>\n注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。<br>\n【附】也可以使用 showkey -a 命令查看按键对应的字符序列。</p>\n<h2 id=\"显示当前系统支持的所有命令的列表他需要怎么做\"><a class=\"markdownIt-Anchor\" href=\"#显示当前系统支持的所有命令的列表他需要怎么做\">#</a> 显示当前系统支持的所有命令的列表，他需要怎么做？</h2>\n<p>使用命令 compgen ­-c，可以打印出所有支持的命令列表。<br>\n[root@localhost ~]$ compgen -c</p>\n<h2 id=\"打印出当前的目录栈你会建议他怎么做\"><a class=\"markdownIt-Anchor\" href=\"#打印出当前的目录栈你会建议他怎么做\">#</a> 打印出当前的目录栈，你会建议他怎么做？</h2>\n<p>使用 Linux 命令 dirs 可以将当前的目录栈打印出来。<br>\n[root@localhost ~]# dirs<br>\n/usr/share/X11<br>\n【附】：目录栈通过 pushd popd 来操作。</p>\n<h2 id=\"系统在多任务运行时不重启机器的条件下把所有正在运行的进程移除\"><a class=\"markdownIt-Anchor\" href=\"#系统在多任务运行时不重启机器的条件下把所有正在运行的进程移除\">#</a> 系统在多任务运行时不重启机器的条件下，把所有正在运行的进程移除？</h2>\n<p>使用 linux 命令 ’disown -r ’可以将所有正在运行的进程移除。</p>\n<h2 id=\"bash-shell-中的hash-命令有什么作用\"><a class=\"markdownIt-Anchor\" href=\"#bash-shell-中的hash-命令有什么作用\">#</a> bash shell 中的 hash 命令有什么作用？</h2>\n<p>linux 命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径，用该命令可以打印出你所使用过的命令以及执行的次数。<br>\n[root@localhost ~]# hash<br>\nhits command<br>\n2 /bin/ls<br>\n2 /bin/su</p>\n<h2 id=\"哪一个bash内置命令能够进行数学运算\"><a class=\"markdownIt-Anchor\" href=\"#哪一个bash内置命令能够进行数学运算\">#</a> 哪一个 bash 内置命令能够进行数学运算。</h2>\n<p>bash shell 的内置命令 let 可以进行整型数的数学运算。<br>\n#! /bin/bash<br>\n…<br>\n…<br>\nlet c=a+b<br>\n…<br>\n…</p>\n<h2 id=\"一页一页地查看一个大文件的内容\"><a class=\"markdownIt-Anchor\" href=\"#一页一页地查看一个大文件的内容\">#</a> 一页一页地查看一个大文件的内容</h2>\n<p>通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.<br>\n[root@localhost ~]# cat file_name.txt | more</p>\n<h2 id=\"数据字典属于哪一个用户的\"><a class=\"markdownIt-Anchor\" href=\"#数据字典属于哪一个用户的\">#</a> 数据字典属于哪一个用户的？</h2>\n<p>数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的</p>\n<h2 id=\"查看一个linux命令的概要与用法假设你在bin目录中偶然看到一个你从没见过的的命令怎样才能知道它的作用和用法呢\"><a class=\"markdownIt-Anchor\" href=\"#查看一个linux命令的概要与用法假设你在bin目录中偶然看到一个你从没见过的的命令怎样才能知道它的作用和用法呢\">#</a> 查看一个 linux 命令的概要与用法？假设你在 /bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？</h2>\n<p>使用命令 whatis 可以先出显示出这个命令的用法简要，比如，你可以使用 whatis zcat 去查看‘zcat’的介绍以及使用简要。<br>\n[root@localhost ~]# whatis zcat<br>\nzcat [gzip] (1) – compress or expand files</p>\n<h2 id=\"查看自己文件系统的磁盘空间配额呢\"><a class=\"markdownIt-Anchor\" href=\"#查看自己文件系统的磁盘空间配额呢\">#</a> 查看自己文件系统的磁盘空间配额呢？</h2>\n<p>使用命令 repquota 能够显示出一个文件系统的配额信息<br>\n【附】只有 root 用户才能够查看其它用户的配额。</p>\n<h2 id=\"root用户\"><a class=\"markdownIt-Anchor\" href=\"#root用户\">#</a> root 用户</h2>\n<p>root 存在于 UNIX 系统（如 AIX、BSD 等）和类 UNIX 系统（如 Debian、Redhat、Ubuntu 等版本的 Linux 系统以及 Android 系统）中，超级用户一般命名为 root，相当于 Windows 系统中的 system 用户。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/01/20/SQL%20interview%20summary%20/",
            "url": "http://example.com/2021/01/20/SQL%20interview%20summary%20/",
            "title": "SQL interview summary",
            "date_published": "2021-01-20T07:50:35.342Z",
            "content_html": "<p>一、第一、第二、第三范式之间的理解<br>\n第一范式（1NF）无重复的列<br>\n　　所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。</p>\n<a id=\"more\"></a>\n<p>1NF 的定义为：符合 1NF 的关系中的每个属性都不可再分<br>\n说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p>\n<p>第二范式（2NF）属性完全依赖于主键<br>\n　　第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。<br>\n第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。</p>\n<p>第三范式（3NF）<br>\n　　满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合 3NF 的要求。</p>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/01/17/Java%20interview%20summary/",
            "url": "http://example.com/2021/01/17/Java%20interview%20summary/",
            "title": "Java interview summary",
            "date_published": "2021-01-17T10:21:37.380Z",
            "content_html": "<h2 id=\"jre与jdk\"><a class=\"markdownIt-Anchor\" href=\"#jre与jdk\">#</a> JRE 与 JDK</h2>\n<p>JRE： Java Runtime Environment<br>\nJDK：Java Development Kit<br>\nJRE 是 java 运行时环境，包含了 java 虚拟机，java 基础类库。是使用 java 语言编写的程序运行所需要的软件环境，是提供给想运行 java 程序的用户使用的。<br>\nJDK 是 java 开发工具包，</p>\n<a id=\"more\"></a>\n<p>是程序员使用 java 语言编写 java 程序所需的开发工具包，是提供给程序员使用的。JDK 包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具：jconsole，jvisualvm 等工具软件，还包含了 java 程序编写所需的文档和 demo 例子程序。如果你需要运行 java 程序，只需安装 JRE 就可以了。如果你需要编写 java 程序，需要安装 JDK。</p>\n<h2 id=\"形参和实参\"><a class=\"markdownIt-Anchor\" href=\"#形参和实参\">#</a> 形参和实参</h2>\n<p>形参：全称为 &quot;形式参数&quot; 是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传如的参数.<br>\n 实参：全称为 &quot;实际参数&quot; 是在调用时传递个该函数的参数.</p>\n<h2 id=\"java四类八种基本数据类型\"><a class=\"markdownIt-Anchor\" href=\"#java四类八种基本数据类型\">#</a> java 四类八种基本数据类型</h2>\n<p>第一类：整型 byte short int long<br>\n 第二类：浮点型 float double<br>\n 第三类：逻辑型 boolean (它只有两个值可取 true false)<br>\n 第四类：字符型 char<br>\nbyte (位)                     占用 1 字节<br>\n short (短整数)             占用 2 字节<br>\n int (整数)                    占用 4 字节<br>\n long (长整数)              占用 8 字节<br>\n float (单精度)              占用 4 字节<br>\n double (双精度)          占用 8 字节<br>\n char (字符)                 占用 2 字节<br>\n boolean (布尔值)        占用 1/8 字节</p>\n<h2 id=\"java创建对象的四种方式\"><a class=\"markdownIt-Anchor\" href=\"#java创建对象的四种方式\">#</a> java 创建对象的四种方式？</h2>\n<p>使用 new 创建对象、运用反射手段、调用对象的 clone () 方法、运用反序列化手段</p>\n<h2 id=\"面向对象的特征有哪些方面\"><a class=\"markdownIt-Anchor\" href=\"#面向对象的特征有哪些方面\">#</a> 面向对象的特征有哪些方面？</h2>\n<p>①　封装<br>\n最常见的是把属性私有化封装在一个类里面，只能通过方法去访问<br>\n②　继承<br>\n子类继承父类，从而继承了父类的方法和属性<br>\n③　抽象<br>\n比如一个英雄类，抽象出了 name,hp 这些属性，使得开发过程中更加易于理解<br>\n④　多态<br>\n多态分操作符的多态和类的多态。 类的多态指父类引用指向子类对象，并且有继承，有重写。</p>\n<h2 id=\"重载和重写的区别\"><a class=\"markdownIt-Anchor\" href=\"#重载和重写的区别\">#</a> 重载和重写的区别？</h2>\n<p>重载指的是在同一个类里面，方法名一样，但是参数不一样<br>\n重写指的是子类继承了父类的某个方法后，重新又写了一遍</p>\n<h2 id=\"final修饰类\"><a class=\"markdownIt-Anchor\" href=\"#final修饰类\">#</a> final 修饰类:</h2>\n<p>final 修饰类即表示此类已经是 “最后的、最终的” 含义。因此，用 final 修饰的类不能被继承，即不能拥有自己的子类。</p>\n<h2 id=\"队列\"><a class=\"markdownIt-Anchor\" href=\"#队列\">#</a> 队列</h2>\n<p>队列（queue）是一种采用先进先出 (FIFO) 策略的抽象数据结构，它的想法来自于生活中排队的策略。顾客在付款结账的时候，按照到来的先后顺序排队结账，先来的顾客先结账，后来的顾客后结账。</p>\n<h2 id=\"栈\"><a class=\"markdownIt-Anchor\" href=\"#栈\">#</a> 栈</h2>\n<p>栈是一种操作受限的线性表只允许从一端插入和删除数据。栈有两种存储方式，即线性存储和链接存储（链表）。栈的一个最重要的特征就是栈的插入和删除只能在栈顶进行，所以每次删除的元素都是最后进栈的元素，故栈也被称为后进先出（LIFO）表。每个栈都有一个栈顶指针，它初始值为 - 1，且总是指向最后一个入栈的元素，栈有两种处理方式，即进栈（push）和出栈（pop），因为在进栈只需要移动一个变量存储空间，所以它的时间复杂度为 O (1)，但是对于出栈分两种情况，栈未满时，时间复杂度也为 O (1)，但是当栈满时，需要重新分配内存，并移动栈内所有数据，所以此时的时间复杂度为 O (n)。以下举例栈结构的两种实现方式，线性存储和链接存储。</p>\n<h2 id=\"多继承与多态\"><a class=\"markdownIt-Anchor\" href=\"#多继承与多态\">#</a> 多继承与多态</h2>\n<p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。<br>\n多继承可以看作是单继承的扩展。所谓多继承是指派生类具有多个基类，派生类与每个基类之间的关系仍可看作是一个单继承。<br>\n多态允许将子类类型的指针赋值给父类类型的指针。</p>\n<h2 id=\"虚函数与纯虚函数\"><a class=\"markdownIt-Anchor\" href=\"#虚函数与纯虚函数\">#</a> 虚函数与纯虚函数</h2>\n<p>虚函数是指一个类中你希望重载的成员函数，当你用一个基类指针或引用指向一个继承类对象的时候，你调用一个虚函数，实际调用的是继承类的版本。<br>\n有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。<br>\n定义纯虚函数就是为了让基类不可实例化化，<br>\n 因为实例化这样的抽象数据结构本身并没有意义.</p>\n<h2 id=\"二叉树的常用性质\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的常用性质\">#</a> 二叉树的常用性质</h2>\n<h3 id=\"常用性质\"><a class=\"markdownIt-Anchor\" href=\"#常用性质\">#</a> 常用性质</h3>\n<p>&lt;1&gt;. 在二叉树的第 i 层上最多有 2^(i-1) 个节点 。（i&gt;=1）<br>\n&lt;2&gt;. 二叉树中如果深度为 k (有 k 层), 那么最多有 2^k-1 个节点。(k&gt;=1）<br>\n&lt;3&gt;. 若二叉树按照从上到下从左到右依次编号，则若某节点编号为 k，则其左右子树根节点编号分别为 2k 和 2k+1;<br>\n&lt;4&gt;. 二叉树分类：满二叉树，完全二叉树<br>\n满二叉树：高度为 h，由 2^h-1 个节点构成的二叉树称为满二叉树。</p>\n<h3 id=\"遍历\"><a class=\"markdownIt-Anchor\" href=\"#遍历\">#</a> 遍历</h3>\n<p>先序遍历：按照根节点 -&gt; 左子树 -&gt; 右子树的顺序访问二叉树<br>\n先序遍历：（1）访问根节点；（2）采用先序递归遍历左子树；（3）采用先序递归遍历右子树；<br>\n中序遍历：按照左子树 -&gt; 根节点 -&gt; 右子树的顺序访问<br>\n中序遍历：（1）采用中序遍历左子树；（2）访问根节点；（3）采用中序遍历右子树<br>\n后序遍历：按照左子树 -&gt; 右子树–&gt; 根节点的顺序访问<br>\n后序遍历：（1）采用后序递归遍历左子树；（2）采用后序递归遍历右子树；（3）访问根节点；</p>\n<h2 id=\"希尔排序\"><a class=\"markdownIt-Anchor\" href=\"#希尔排序\">#</a> 希尔排序：</h2>\n<p>间隔为增量跳跃取数据</p>\n<h2 id=\"序列化和反序列化的定义\"><a class=\"markdownIt-Anchor\" href=\"#序列化和反序列化的定义\">#</a> 序列化和反序列化的定义：</h2>\n<p>(1) Java 序列化就是指把 Java 对象转换为字节序列的过程<br>\n Java 反序列化就是指把字节序列恢复为 Java 对象的过程。<br>\n(2) 序列化最重要的作用：在传递和保存对象时。保证对象的完整性和可传递性。对象转换为有序字节流，以便在网络上传输或者保存在本地文件中。<br>\n反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。<br>\n总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）</p>\n<h2 id=\"osi七层模型\"><a class=\"markdownIt-Anchor\" href=\"#osi七层模型\">#</a> OSI 七层模型</h2>\n<p>物理层<br>\n在 OSI 参考模型中，物理层（Physical Layer）是参考模型的最低层，也是 OSI 模型的第一层。<br>\n物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。<br>\n数据链路层<br>\n数据链路层（Data Link Layer）是 OSI 模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。<br>\n网络层<br>\n网络层（Network Layer）是 OSI 模型的第三层，它是 OSI 参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。<br>\n传输层<br>\n OSI 下 3 层的主要任务是数据通信，上 3 层的任务是数据处理。而传输层（Transport Layer）是 OSI 模型的第 4 层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。<br>\n该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。<br>\n会话层<br>\n会话层（Session Layer）是 OSI 模型的第 5 层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。<br>\n表示层<br>\n表示层（Presentation Layer）是 OSI 模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是 “处理用户信息的表示问题，如编码、数据格式转换和加密解密” 等。<br>\n应用层<br>\n应用层（Application Layer）是 OSI 参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。<br>\nOSI7 层模型的小结<br>\n在 7 层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面 4 层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第 4 层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上 3 层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下 4 层主要完成通信子网的功能，上 3 层主要完成资源子网的功能。</p>\n<h2 id=\"tcpip分层模型\"><a class=\"markdownIt-Anchor\" href=\"#tcpip分层模型\">#</a> TCP/IP 分层模型</h2>\n<p>第一层：网络接口层<br>\n　　包括用于协作 IP 数据在已有网络介质上传输的协议。实际上 TCP/IP 标准并不定义与 ISO 数据链路层和物理层相对应的功能。相反，它定义像地址解析协议 (Address Resolution Protocol,ARP) 这样的协议，提供 TCP/IP 协议的数据结构和实际物理硬件之间的接口。<br>\n　　第二层：网间层<br>\n　　对应于 OSI 七层参考模型的网络层。本层包含 IP 协议、RIP 协议 (Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议 (Internet Control Message Protocol,ICMP) 用来提供网络诊断信息。<br>\n　　第三层：传输层<br>\n　　对应于 OSI 七层参考模型的传输层，它提供两种端到端的通信服务。其中 TCP 协议 (Transmission Control Protocol) 提供可靠的数据流运输服务，UDP 协议 (Use Datagram Protocol) 提供不可靠的用户数据报服务。<br>\n　　第四层：应用层<br>\n　　对应于 OSI 七层参考模型的应用层和表达层。因特网的应用层协议包括 Finger、Whois、FTP (文件传输协议)、Gopher、HTTP (超文本传输协议)、Telent (远程终端协议)、SMTP (简单邮件传送协议)、IRC (因特网中继会话)、NNTP（网络新闻传输协议）等，这也是本书将要讨论的重点。</p>\n<h2 id=\"arraylist和linkedlist的区别\"><a class=\"markdownIt-Anchor\" href=\"#arraylist和linkedlist的区别\">#</a> ArrayList 和 LinkedList 的区别</h2>\n<p>ArrayList 是数组结构，所以定位很快，但是插入和删除很慢<br>\n LinkedList 是双向链表结构，所以插入和删除很快，但是定位很慢</p>\n<h2 id=\"equals和的区别\"><a class=\"markdownIt-Anchor\" href=\"#equals和的区别\">#</a> equals 和 == 的区别？</h2>\n<p>== 是判断两个变量或实例是不是指向同一个内存空间，equals 是判断两个变量或实例所指向的内存空间的值是不是相同<br>\n == 是指对内存地址进行比较 ， equals () 是对字符串的内容进行比较<br>\n == 指引用是否相同， equals () 指的是值是否相同</p>\n<h2 id=\"try-里有一个return语句那么紧跟在这个try后的finally-里的code会不会被执行什么时候被执行在return前还是后\"><a class=\"markdownIt-Anchor\" href=\"#try-里有一个return语句那么紧跟在这个try后的finally-里的code会不会被执行什么时候被执行在return前还是后\">#</a> try {} 里有一个 return 语句，那么紧跟在这个 try 后的 finally {} 里的 code 会不会被执行，什么时候被执行，在 return 前还是后？</h2>\n<p>try 里的 return 和 finally 里的 return 都会执行，但是当前方法只会采纳 finally 中 return 的值。无论 try、catch 块中执行怎样的代码，出现怎样的情况，异常处理的 finally 块总会被执行。</p>\n<h2 id=\"for循环中的return-break-continue的区别\"><a class=\"markdownIt-Anchor\" href=\"#for循环中的return-break-continue的区别\">#</a> for 循环中的 return break continue 的区别？</h2>\n<p>执行 return 后，不仅结束了该循环，当前函数也结束了，后面的语句不再执行；break 会终止并跳出它所在的循环；continue 是跳出本次循环，进入下一次循环的入口处 执行下一次循环</p>\n<h2 id=\"error和exception有什么区别\"><a class=\"markdownIt-Anchor\" href=\"#error和exception有什么区别\">#</a> Error 和 Exception 有什么区别？</h2>\n<p>Error 和 Exception 都实现了 Throwable 接口<br>\n Error 指的是 JVM 层面的错误，比如内存不足 OutOfMemoryError<br>\nException 指的是代码逻辑的异常，比如下标越界 OutOfIndexException</p>\n<h2 id=\"集合类都有哪些主要方法\"><a class=\"markdownIt-Anchor\" href=\"#集合类都有哪些主要方法\">#</a> 集合类都有哪些？主要方法？</h2>\n<p>常见的集合：ArrayList,LinkedList,HashSet,HashMap,TreeSet 等等<br>\n常见方法：size ()、add ()、remove ()<br>\n String 常用的方法：length ()、valueOf ()、split ()、substring ()</p>\n<h2 id=\"多线程有几种实现方法都是什么\"><a class=\"markdownIt-Anchor\" href=\"#多线程有几种实现方法都是什么\">#</a> 多线程有几种实现方法，都是什么？</h2>\n<p>通常来讲，Java 创建一个线程有三种方式<br>\n①　继承一个 Thread 类<br>\n②　实现 Runnable 接口<br>\n③　匿名内部类</p>\n<h2 id=\"list-set-map的区别\"><a class=\"markdownIt-Anchor\" href=\"#list-set-map的区别\">#</a> List, Set, Map 的区别？</h2>\n<p>list 是最常用的 它其实就是一种可以自由改变长度的数组<br>\n set 和 list 基本的用法差不多 区别在于 set 里不能放相同的元素<br>\n至于 map 这个和上边 2 个在用法上有很大差别 map 里储存的是键值对 可以根据键来值搜索值 键是唯一的 值可以重复… 学 Servlet 和 jsp 的时候 会有大量的 map 的应用</p>\n<h2 id=\"和的区别\"><a class=\"markdownIt-Anchor\" href=\"#和的区别\">#</a> &amp; 和 &amp;&amp; 的区别？</h2>\n<p>&amp; 有两个作用，分别是 位与 和 逻辑与<br>\n &amp;&amp; 就是逻辑与<br>\n作为逻辑与， &amp; 和 &amp;&amp; 分别表示长路与和短路与<br>\n长路与 两侧，都会被运算<br>\n短路与 只要第一个是 false，第二个就不进行运算了</p>\n<h2 id=\"五个常见到的runtime-exception\"><a class=\"markdownIt-Anchor\" href=\"#五个常见到的runtime-exception\">#</a> 五个常见到的 runtime exception。</h2>\n<p>NullPointerException 空指针异常<br>\n ArithmeticException 算术异常，比如除数为零<br>\n ClassCastException 类型转换异常<br>\n ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常<br>\n IndexOutOfBoundsException 数组下标越界异常<br>\n NegativeArraySizeException 为数组分配的空间是负数异常</p>\n<h2 id=\"servlet的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#servlet的生命周期\">#</a> servlet 的生命周期？</h2>\n<p>一个 Servlet 的生命周期由 实例化，初始化，提供服务，销毁，被回收 几个步骤组成</p>\n<h2 id=\"ssm\"><a class=\"markdownIt-Anchor\" href=\"#ssm\">#</a> SSM：</h2>\n<p>Spring+SpringMVC+Mybatis</p>\n<h2 id=\"spring\"><a class=\"markdownIt-Anchor\" href=\"#spring\">#</a> Spring</h2>\n<h3 id=\"spring-在ssm中起什么作用\"><a class=\"markdownIt-Anchor\" href=\"#spring-在ssm中起什么作用\">#</a> Spring 在 ssm 中起什么作用？</h3>\n<p>Spring：轻量级框架<br>\n作用：Bean 工厂，用来管理 Bean 的生命周期和框架集成。<br>\n两大核心：<br>\n①. IOC/DI (控制反转 / 依赖注入) ：把 dao 依赖注入到 service 层，service 层反转给 action 层，Spring 顶层容器为 BeanFactory。<br>\n②. AOP：面向切面编程</p>\n<h3 id=\"spring的事务\"><a class=\"markdownIt-Anchor\" href=\"#spring的事务\">#</a> Spring 的事务？</h3>\n<p>编程式事务管理：编程方式管理事务，极大灵活性，难维护。<br>\n声明式事务管理：可以将业务代码和事务管理分离，用注解和 xml 配置来管理事务。</p>\n<h3 id=\"ioc-在项目中的作用\"><a class=\"markdownIt-Anchor\" href=\"#ioc-在项目中的作用\">#</a> IOC 在项目中的作用？</h3>\n<p>作用：Ioc 解决对象之间的依赖问题，把所有 Bean 的依赖关系通过配置文件或注解关联起来，降低了耦合度。</p>\n<h3 id=\"spring的配置文件中的内容\"><a class=\"markdownIt-Anchor\" href=\"#spring的配置文件中的内容\">#</a> Spring 的配置文件中的内容？</h3>\n<p>开启事务注解驱动<br>\n事务管理器<br>\n开启注解功能，并配置扫描包<br>\n配置数据库<br>\n配置 SQL 会话工厂，别名，映射文件<br>\n不用编写 Dao 层的实现类</p>\n<h3 id=\"spring下的注解\"><a class=\"markdownIt-Anchor\" href=\"#spring下的注解\">#</a> Spring 下的注解？</h3>\n<p>注册：@Controller @Service @Component<br>\n 注入：@Autowired @Resource<br>\n 请求地址：@RequestMapping<br>\n 返回具体数据类型而非跳转：@ResponseBody</p>\n<h3 id=\"spring-di-的三种方式\"><a class=\"markdownIt-Anchor\" href=\"#spring-di-的三种方式\">#</a> Spring DI 的三种方式？</h3>\n<p>构造器注入：通过构造方法初始化<br>\n<constructor-arg index=\"0\" type=\"java.lang.String\" value=\"宝马\"></constructor-arg><br>\nsetter 方法注入：通过 setter 方法初始化<br>\n<property name=\"id\" value=\"1111\"></property><br>\n接口注入</p>\n<h3 id=\"spring主要使用了什么模式\"><a class=\"markdownIt-Anchor\" href=\"#spring主要使用了什么模式\">#</a> Spring 主要使用了什么模式？</h3>\n<p>工厂模式：每个 Bean 的创建通过方法<br>\n单例模式：默认的每个 Bean 的作用域都是单例<br>\n代理模式：关于 Aop 的实现通过代理模式</p>\n<h3 id=\"iocaop的实现原理\"><a class=\"markdownIt-Anchor\" href=\"#iocaop的实现原理\">#</a> IOC，AOP 的实现原理？</h3>\n<p>IOC：通过反射机制生成对象注入<br>\n AOP：动态代理</p>\n<h3 id=\"什么是ioc\"><a class=\"markdownIt-Anchor\" href=\"#什么是ioc\">#</a> . 什么是 IOC？</h3>\n<p>IOC： Inversion of control 反转控制。 比如以前创建一个对象，需要自己主动 new 一个对象，通过 IOC，对象的创建交由 Spring 框架 创建，开发人员直接使用已经创建好的对象。</p>\n<h3 id=\"什么是di\"><a class=\"markdownIt-Anchor\" href=\"#什么是di\">#</a> 什么是 DI？</h3>\n<p>DI： Dependency Injection 依赖注入。 通过 IOC 创建对象的时候，可以注入字符串甚至其他对象。 比如 DAO 就会注入 session factory.<br>\n 通常 IOC 和 DI 是紧密结合，一起使用的</p>\n<h3 id=\"什么是aop\"><a class=\"markdownIt-Anchor\" href=\"#什么是aop\">#</a> 什么是 AOP？</h3>\n<p>AOP: 面向切面编程。<br>\n把功能划分为核心业务功能和其他的周边辅助功能，比如日志，性能统计，事务等等。 其他的周边辅助功能可以都看作切面功能。核心功能和切面功能分别独立开发，通过面向切面编程，可以有机的把核心业务功能和切面功能根据需求结合在一起。 比如增加操作可以和事务切面结合在一起，查询操作可以和性能统计切面结合在一起。<br>\n在配置方面，要配置切面，切点，并且通过 aspect:config 把切面和切点结合起来</p>\n<h2 id=\"springmvc\"><a class=\"markdownIt-Anchor\" href=\"#springmvc\">#</a> SpringMvc</h2>\n<h3 id=\"springmvc-的控制器是不是单例模式如果是有什么问题怎么解决\"><a class=\"markdownIt-Anchor\" href=\"#springmvc-的控制器是不是单例模式如果是有什么问题怎么解决\">#</a> SpringMvc 的控制器是不是单例模式，如果是，有什么问题，怎么解决？</h3>\n<p>问题：单例模式，在多线程访问时有线程安全问题<br>\n解决方法：不要用同步，在控制器里面不能写字段</p>\n<h3 id=\"springmvc-中控制器的注解\"><a class=\"markdownIt-Anchor\" href=\"#springmvc-中控制器的注解\">#</a> SpringMvc 中控制器的注解？</h3>\n<p>@Controller：该注解表明该类扮演控制器的角色</p>\n<h3 id=\"requestmapping-注解用在类上的作用\"><a class=\"markdownIt-Anchor\" href=\"#requestmapping-注解用在类上的作用\">#</a> @RequestMapping 注解用在类上的作用？</h3>\n<p>作用：用来映射一个 URL 到一个类或者一个特定的处理方法上</p>\n<h3 id=\"前台多个参数这些参数都是一个对象快速得到对象\"><a class=\"markdownIt-Anchor\" href=\"#前台多个参数这些参数都是一个对象快速得到对象\">#</a> 前台多个参数，这些参数都是一个对象，快速得到对象？</h3>\n<p>方法：直接在方法中声明这个对象，SpringMvc 就自动把属性赋值到这个对象里面</p>\n<h3 id=\"springmvc中函数的返回值\"><a class=\"markdownIt-Anchor\" href=\"#springmvc中函数的返回值\">#</a> SpringMvc 中函数的返回值？</h3>\n<p>String，ModelAndView，List，Set 等<br>\n一般 String，Ajax 请求，返回一个 List 集合</p>\n<h3 id=\"springmvc中的转发和重定向\"><a class=\"markdownIt-Anchor\" href=\"#springmvc中的转发和重定向\">#</a> SpringMvc 中的转发和重定向？</h3>\n<p>转发： return：“hello”<br>\n 重定向 ：return：“redirect:hello.jsp”<br>\n 通过 JackSon 框架把 java 里面对象直接转换成 js 可识别的 json 对象，具体步骤如下：<br>\n加入 JackSon.jar<br>\n 在配置文件中配置 json 的映射<br>\n在接受 Ajax 方法里面直接返回 Object，list 等，方法前面需要加上注解 @ResponseBody</p>\n<h3 id=\"springmvc的工作流程\"><a class=\"markdownIt-Anchor\" href=\"#springmvc的工作流程\">#</a> SpringMvc 的工作流程</h3>\n<p>浏览器→发送请求→前端控制器（DispatcherServlet）→请求→处理器映射器 (HandlerMapping)→返回处理器执行链→前端控制器（DispatcherServlet）→发送处理器执行链→处理器适配器 (HandlerAdatper)→执行→处理器 (Handler)→ModelAndView→处理器适配器 (HandlerAdatper)→modelandview→前端控制器（DispatcherServlet）→modelandview→视图解析器→view→前端控制器（DispatcherServlet）→model→视图 (view)→前端控制器（DispatcherServlet）→响应→浏览器</p>\n<h3 id=\"struts2-和-springmvc的区别\"><a class=\"markdownIt-Anchor\" href=\"#struts2-和-springmvc的区别\">#</a> Struts2 和 SpringMvc 的区别？</h3>\n<p>入口不同：<br>\nStruts2：filter 过滤器<br>\n SpringMvc：一个 Servlet 即前端控制器</p>\n<p>开发方式不同：<br>\nStruts2：基于类开发，传递参数通过类的属性，只能设置为多例<br>\n SpringMvc：基于方法开发 (一个 url 对应一个方法)，请求参数传递到方法形参，可以为单例也可以为多例 (建议单例)</p>\n<p>请求方式不同：<br>\nStruts2：值栈村塾请求和响应的数据，通过 OGNL 存取数据<br>\n SpringMvc：通过参数解析器将 request 请求内容解析，给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 request 域传输到页面，jsp 视图解析器默认使用的是 jstl。</p>\n<h2 id=\"mybatis\"><a class=\"markdownIt-Anchor\" href=\"#mybatis\">#</a> Mybatis</h2>\n<h3 id=\"ibatis和mybatis\"><a class=\"markdownIt-Anchor\" href=\"#ibatis和mybatis\">#</a> Ibatis 和 Mybatis？</h3>\n<p>Ibatis：2010 年，apache 的 Ibatis 框架停止更新，并移交给了 google 团队，同时更名为 MyBatis。从 2010 年后 Ibatis 在没更新过，彻底变成了一个孤儿框架。一个没人维护的框架注定被 mybatis 拍在沙滩上。<br>\nMybatis：Ibatis 的升级版本。</p>\n<h3 id=\"什么是mybatis的接口绑定有什么好处\"><a class=\"markdownIt-Anchor\" href=\"#什么是mybatis的接口绑定有什么好处\">#</a> 什么是 Mybatis 的接口绑定，有什么好处？</h3>\n<p>Mybatis 实现了 DAO 接口与 xml 映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。</p>\n<h3 id=\"什么情况用注解什么情况用xml绑定\"><a class=\"markdownIt-Anchor\" href=\"#什么情况用注解什么情况用xml绑定\">#</a> 什么情况用注解，什么情况用 xml 绑定？</h3>\n<p>注解使用情况：Sql 语句简单时<br>\n xml 绑定使用情况：xml 绑定 (@RequestMap 用来绑定 xml 文件)</p>\n<h3 id=\"mybatis在核心处理类叫什么\"><a class=\"markdownIt-Anchor\" href=\"#mybatis在核心处理类叫什么\">#</a> Mybatis 在核心处理类叫什么？</h3>\n<p>SqlSession</p>\n<h3 id=\"查询表名和返回实体bean对象不一致如何处理\"><a class=\"markdownIt-Anchor\" href=\"#查询表名和返回实体bean对象不一致如何处理\">#</a> 查询表名和返回实体 Bean 对象不一致，如何处理？</h3>\n<p>映射键值对即可<br>\n<result column=\"title\" property=\"title\" javaType=\"java.lang.String\"/><br>\ncolumn：数据库中表的列名<br>\n property：实体 Bean 中的属性名</p>\n<h3 id=\"mybatis的好处\"><a class=\"markdownIt-Anchor\" href=\"#mybatis的好处\">#</a> Mybatis 的好处？</h3>\n<p>把 Sql 语句从 Java 中独立出来。<br>\n封装了底层的 JDBC，API 的调用，并且能够将结果集自动转换成 JavaBean 对象，简化了 Java 数据库编程的重复工作。<br>\n自己编写 Sql 语句，更加的灵活。<br>\n入参无需用对象封装（或者 map 封装）, 使用 @Param 注解</p>\n<h3 id=\"mybatis配置一对多\"><a class=\"markdownIt-Anchor\" href=\"#mybatis配置一对多\">#</a> Mybatis 配置一对多？</h3>\n<collection property=\"topicComment\" column=\"id\" ofType=\"com.tmf.bbs.pojo.Comment\" select=\"selectComment\" />\nproperty：属性名\ncolumn：共同列\nofType：集合中元素的类型\nselect：要连接的查询\n<h3 id=\"mybatis配置一对一\"><a class=\"markdownIt-Anchor\" href=\"#mybatis配置一对一\">#</a> Mybatis 配置一对一？</h3>\n<association property=\"topicType\" select=\"selectType\" column=\"topics_type_id\" javaType=\"com.tmf.bbs.pojo.Type\"/>\nproperty：属性名\nselect：要连接的查询\ncolumn：共同列\njavaType：集合中元素的类型\n<h3 id=\"和-的区别\"><a class=\"markdownIt-Anchor\" href=\"#和-的区别\">#</a> ${} 和 #{} 的区别？</h3>\n<p>${}： 简 单 字 符 串 替 换 ， 把 {}：简单字符串替换，把：简单字符串替换，把 {} 直接替换成变量的值，不做任何转换，这种是取值以后再去编译 SQL 语句。<br>\n#{}：预编译处理，sql 中的 #{} 替换成？，补全预编译语句，有效的防止 Sql 语句注入，这种取值是编译好 SQL 语句再取值。<br>\n总结：一般用 #{} 来进行列的代替</p>\n<h3 id=\"获取上一次自动生成的主键值\"><a class=\"markdownIt-Anchor\" href=\"#获取上一次自动生成的主键值\">#</a> 获取上一次自动生成的主键值？</h3>\n<p>select last _insert_id()</p>\n<h3 id=\"mybatis如何分页分页原理\"><a class=\"markdownIt-Anchor\" href=\"#mybatis如何分页分页原理\">#</a> Mybatis 如何分页，分页原理？</h3>\n<p>RowBounds 对象分页<br>\n在 Sql 内直接书写，带有物理分页</p>\n<h3 id=\"mybatis工作原理\"><a class=\"markdownIt-Anchor\" href=\"#mybatis工作原理\">#</a> Mybatis 工作原理？</h3>\n<p>通过 SqlSessionFactoryBuilder 从 mybatis-config.xml 配置文件中构建出 SqlSessionFactory。<br>\nSqlSessionFactory 开启一个 SqlSession，通过 SqlSession 实例获得 Mapper 对象并且运行 Mapper 映射的 Sql 语句。<br>\n完成数据库的 CRUD 操作和事务提交，关闭 SqlSession。</p>\n<h2 id=\"状态和转换详解七态\"><a class=\"markdownIt-Anchor\" href=\"#状态和转换详解七态\">#</a> 状态和转换详解 (七态)</h2>\n<p>操作系统之进程的状态和转换详解 (七态)</p>\n<h3 id=\"三态模型\"><a class=\"markdownIt-Anchor\" href=\"#三态模型\">#</a> 三态模型</h3>\n<p>1. 运行态 (running): 占有处理器正在运行<br>\n 2. 就绪态 (ready): 具备运行条件，等待系统分配处理器以便运行<br>\n 3. 等待态 (blocked): 不具备运行条件，正在等待某个事件的完成<br>\n运行态 —→等待态：等待使用资源；如等待外设传输；等待人工干预。<br>\n等待态 —→就绪态：资源得到满足；如外设传输结束；人工干预完成。<br>\n运行态 —→就绪态：运行时间片到；出现有更高优先权进程。<br>\n就绪态 —→运行态：CPU 空闲时选择一个就绪进程。</p>\n<h3 id=\"五态模型\"><a class=\"markdownIt-Anchor\" href=\"#五态模型\">#</a> 五态模型</h3>\n<p>建态（new）和终止态（exit ）<br>\nNULL—→新建态：执行一个程序，创建一个子进程。<br>\n新建态 —→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。<br>\n运行态 —→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。<br>\n终止态 —→NULL：完成善后操作。<br>\n就绪态 —→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。<br>\n等待态 —→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。</p>\n<h3 id=\"七态模型\"><a class=\"markdownIt-Anchor\" href=\"#七态模型\">#</a> 七态模型</h3>\n<p>挂起就绪态（ready,suspend）<br>\n挂起就绪态表明了进程具备运行条件但目前在二级存储器中，只有当它被对换到主存才能被调度执行<br>\n挂起等待态（blocked,suspend）挂起等待态则表明了进程正在等待某一个事件且在二级存储器中。<br>\n等待态 —→挂起等待态：如果当前不存在就绪进程，那么至少有一个等待态进程将被对换出去成为挂起等待态；操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。<br>\n挂起等待态 —→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态。<br>\n挂起就绪态 —→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。<br>\n就绪态 —→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。<br>\n挂起等待态 —→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间，而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。<br>\n运行态 —→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 CPU，，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。<br>\n新建态 —→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。</p>\n<h2 id=\"进程的挂起\"><a class=\"markdownIt-Anchor\" href=\"#进程的挂起\">#</a> 进程的挂起</h2>\n<p>到目前为止，我们或多或少总是假设所有的进程都在内存中。事实上，可能出现这样一些情况，例如由于进程的不断创建，系统的资源已经不能满足进程运行的要求，这个时候就必须把某些进程挂起（suspend），对换到磁盘镜像区中，暂时不参与进程调度，起到平滑系统操作负荷的目的。</p>\n<h3 id=\"引起进程挂起的原因是多样的主要有\"><a class=\"markdownIt-Anchor\" href=\"#引起进程挂起的原因是多样的主要有\">#</a> 引起进程挂起的原因是多样的，主要有：</h3>\n<p>1. 系统中的进程均处于等待状态，处理器空闲，此时需要把一些阻塞进程对换出去，以腾出足够的内存装入就绪进程运行。<br>\n2. 进程竞争资源，导致系统资源不足，负荷过重，此时需要挂起部分进程以调整系统负荷，保证系统的实时性或让系统正常运行。<br>\n3. 把一些定期执行的进程（如审计程序、监控程序、记账程序）对换出去，以减轻系统负荷。<br>\n4. 用户要求挂起自己的进程，以便根据中间执行情况和中间结果进行某些调试、检查和改正。<br>\n5. 父进程要求挂起自己的后代进程，以进行某些检查和改正。<br>\n6. 操作系统需要挂起某些进程，检查运行中资源使用情况，以改善系统性能；或当系统出现故障或某些功能受到破坏时，需要挂起某些进程以排除故障。</p>\n<h3 id=\"一个挂起进程具有如下特征\"><a class=\"markdownIt-Anchor\" href=\"#一个挂起进程具有如下特征\">#</a> 一个挂起进程具有如下特征：</h3>\n<ol>\n<li>该进程不能立即被执行。</li>\n<li>挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。</li>\n<li>进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。</li>\n<li>结束进程挂起状态的命令只能通过操作系统或父进程发出。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2021/01/08/hello-world/",
            "url": "http://example.com/2021/01/08/hello-world/",
            "title": "Hello World",
            "date_published": "2021-01-08T13:46:11.333Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"markdownIt-Anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"markdownIt-Anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo new <span class=\"token string\">\"My New Post\"</span></pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"markdownIt-Anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo server</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"markdownIt-Anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo generate</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"markdownIt-Anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><figcaption data-lang=\"bash\"><span>h</span></figcaption><table><tr><td data-num=\"1\"></td><td><pre>$ hexo deploy</pre></td></tr></table></figure><p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}