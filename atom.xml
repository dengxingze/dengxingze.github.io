<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>DXZ</title>
    <link href="http://example.com" />
    <updated>2021-01-21T13:06:14.508Z</updated>
    <entry>
        <id>http://example.com/2021/01/21/HTML+CSS+JS%20interview%20summary/</id>
        <title>HTML+CSS+JS interview summary</title>
        <link rel="alternate" href="http://example.com/2021/01/21/HTML+CSS+JS%20interview%20summary/"/>
        <content type="html">&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcWlpbGVlL3AvNjkxNzk0Mi5odG1s&#34;&gt;https://www.cnblogs.com/qiilee/p/6917942.html&lt;/span&gt;&lt;br&gt;
1、 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么？&lt;br&gt;
IE: trident 内核&lt;br&gt;
 Firefox：gecko 内核&lt;br&gt;
 Safari:webkit 内核&lt;br&gt;
 Opera: 以前是 presto 内核，Opera 现已改用 Google Chrome 的 Blink 内核&lt;br&gt;
 Chrome:Blink (基于 webkit，Google 与 Opera Software 共同开发)&lt;/p&gt;
&lt;p&gt;2、你能描述一下渐进增强和优雅降级之间的不同吗？&lt;br&gt;
 渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。&lt;br&gt;
优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。&lt;/p&gt;
&lt;p&gt;3、请描述一下 cookies，sessionStorage 和 localStorage 的区别？&lt;br&gt;
sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。&lt;br&gt;
web storage 和 cookie 的区别&lt;br&gt;
 Web Storage 的概念和 cookie 相似，区别是它是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽，另外 cookie 还需要指定作用域，不可以跨域调用。&lt;br&gt;
除此之外，Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie。但是 Cookie 也是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地 “存储” 数据而生。&lt;/p&gt;
&lt;p&gt;4、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。&lt;br&gt;
图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。&lt;br&gt;
如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。&lt;br&gt;
如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。&lt;br&gt;
如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。&lt;br&gt;
如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。&lt;/p&gt;
&lt;p&gt;5、什么是 Css Hack？ie6,7,8 的 hack 分别是什么？&lt;br&gt;
针对不同的浏览器写不同的 CSS code 的过程，就是 CSS hack。&lt;/p&gt;
&lt;p&gt;#test{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;width:300px;  

height:300px;  

      /*firefox*/

background-color:red\9;      /*all ie*/

    /*ie8*/

+background-color:pink;        /*ie7*/

_       /*ie6*/    &amp;#125; 

:root #test &amp;#123; background-color:purple\9; &amp;#125;  /*ie9*/

@media all and (min-width:0px)&amp;#123; #test &amp;#123;&amp;#125; &amp;#125;  /*opera*/

@media screen and (-webkit-min-device-pixel-ratio:0)&amp;#123; #test &amp;#123;background-color:gray;&amp;#125; &amp;#125;       /*chrome and safari*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6、Sass、LESS 是什么？大家为什么要使用他们？&lt;br&gt;
他们是 CSS 预处理器。他是 CSS 上的一种抽象层。他们是一种特殊的语法 / 语言编译成 CSS。&lt;br&gt;
例如 Less 是一种动态样式语言。将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可一在服务端运行 (借助 Node.js)。&lt;br&gt;
为什么要使用它们？&lt;br&gt;
结构清晰，便于扩展。&lt;br&gt;
可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对浏览器语法差异的重复处理，减少无意义的机械劳动。&lt;br&gt;
可以轻松实现多重继承。&lt;br&gt;
完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。&lt;/p&gt;
&lt;p&gt;7、html 常见兼容性问题？&lt;br&gt;
1. 双边距 BUG float 引起的  使用 display&lt;br&gt;
2.3 像素问题 使用 float 引起的 使用 dislpay:inline -3px&lt;br&gt;
3. 超链接 hover 点击后失效  使用正确的书写顺序 link visited hover active&lt;br&gt;
&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovLzQuSWU=&#34;&gt;4.Ie&lt;/span&gt; z-index 问题 给父级添加 position:relative&lt;br&gt;
5.Png 透明 使用 js 代码 改&lt;br&gt;
 6.Min-height 最小高度 ！Important 解决’&lt;br&gt;
7.select 在 ie6 下遮盖 使用 iframe 嵌套&lt;br&gt;
 8. 为什么没有办法定义 1px 左右的宽度容器（IE6 默认的行高造成的，使用 over:hidden,zoom:0.08 line-height:1px）&lt;br&gt;
9.IE5-8 不支持 opacity，解决办法：&lt;br&gt;
.opacity {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;opacity: 0.4

filter: alpha(opacity=60); /* for IE5-7 */

-ms-filter: &amp;quot;progid:DXImageTransform.Microsoft.Alpha(Opacity=60)&amp;quot;; /* for IE 8*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;IE6 不支持 PNG 透明背景，解决办法: IE6 下使用 gif 图片&lt;br&gt;
 8、描述一个”reset” 的 CSS 文件并如何使用它。知道 normalize.css 吗？你了解他们的不同    之处？&lt;br&gt;
因为浏览器的品种很多，每个浏览器的默认样式也是不同的，比如&lt;button&gt;标签，在 IE 浏览器、Firefox 浏览器以及 Safari 浏览器中的样式都是不同的，所以，通过重置 button 标签的 CSS 属性，然后再将它统一定义，就可以产生相同的显示效果。&lt;br&gt;
你可能会用 Normalize 来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。&lt;/p&gt;
&lt;p float:left;width:200px;height:200px;=&#34;&#34;&gt;9、一边宽度固定，另一边自适应？&lt;br&gt;
1）第一种：float 单一层浮动法&lt;br&gt;
例如：左侧固定成 100px; 则核心代码 左侧：width:100px;float:left;&lt;br&gt;
 右侧 width:auto;margin-left:100px;&lt;br&gt;
2）第二种：定位 ，在固定元素上加入绝对定位，自适应元素设置成 margin-left: 固定元素的宽度&lt;br&gt;
 3）通过 BFC 规则实现&lt;br&gt;
例如：.left&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     .right&amp;#123;width:100%;overflow:hidden;height:200px&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;10、什么是圣杯布局？&lt;br&gt;
左右两边的内容保持不变，中间的内容可以根据屏幕的大小的改变而改变。&lt;br&gt;
1 .content {&lt;br&gt;
2 padding: 0 200px;&lt;br&gt;
3 height: 200px;&lt;br&gt;
4 min-width: 200px;&lt;br&gt;
5 }&lt;br&gt;
.left {&lt;br&gt;
6 width: 200px;&lt;br&gt;
7 height: 200px;&lt;br&gt;
8 background: red;&lt;br&gt;
9 float: left;&lt;br&gt;
10 margin-left: -200px;&lt;br&gt;
11 }&lt;br&gt;
12 .right {&lt;br&gt;
13 width: 200px;&lt;br&gt;
14 height: 200px;&lt;br&gt;
15 background: yellow;&lt;br&gt;
16 float: right;&lt;br&gt;
17 margin-right: -200px;&lt;br&gt;
18 }&lt;br&gt;
19 .center {&lt;br&gt;
20 width: 100%;&lt;br&gt;
21 min-width: 200px;&lt;br&gt;
22 height: 200px;&lt;br&gt;
23 background: green;&lt;br&gt;
24 float: left;&lt;br&gt;
25 }&lt;br&gt;
26 &lt;/style&gt;&lt;br&gt;
27 &lt;/head&gt;&lt;br&gt;
28 &lt;body&gt;&lt;br&gt;
29 &lt;div class=&#34;content&#34;&gt;&lt;br&gt;
30 &lt;div class=&#34;left&#34;&gt;&lt;/div&gt;&lt;br&gt;
31 &lt;div class=&#34;center&#34;&gt;&lt;/div&gt;&lt;br&gt;
32 &lt;div class=&#34;right&#34;&gt;&lt;/div&gt;&lt;br&gt;
33 &lt;/div&gt;&lt;/p&gt;
&lt;p&gt;11、div 中子元素居中的三种方式？&lt;br&gt;
首先 div 设置为相对定位 relative, 子元素设置为绝对定位 absolute&lt;br&gt;
 第一种 #div.img {position:absolute;left:0;top:0;bottom:0;right:0;margin:auto}&lt;br&gt;
 第二种&lt;br&gt;
 #div.img {position:absoulute;left:50%;top:50%;margin-left:img 的 1/2width；margin-top:-img 的 1/2height;}&lt;br&gt;
HTML5+CSS3&lt;br&gt;
1、html5 有哪些新特性、移除了那些元素？如何处理 HTML5 新标签的浏览器兼容问题？&lt;/p&gt;
&lt;p&gt;新特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;拖拽释放 (Drag and drop) API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语义化更好的内容标签（header,nav,footer,aside,article,section）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;音频、视频 API (audio,video)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;画布 (Canvas) API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地理 (Geolocation) API&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sessionStorage 的数据在浏览器关闭后自动删除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表单控件，calendar、date、time、email、url、search&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新的技术 webworker, websocket, Geolocation&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;移除的元素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;纯表现的元素：basefont，big，center，font, s，strike，tt，u；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对可用性产生负面影响的元素：frame，frameset，noframes；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTML5 兼容性解决方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架）：&lt;/li&gt;
&lt;/ol&gt;
&lt;!--[if lt IE 9]&gt;

&lt;script&gt; src=&#34;http://html5shim.googlecode.com/svn/trunk/html5.js&#34;&lt;/script&gt;

&lt;![endif]--&gt;
&lt;p&gt;2 你如何对网站的文件和资源进行优化？&lt;/p&gt;
&lt;p&gt;文件合并&lt;/p&gt;
&lt;p&gt;文件最小化 / 文件压缩&lt;/p&gt;
&lt;p&gt;使用 CDN 托管&lt;/p&gt;
&lt;p&gt;缓存的使用&lt;/p&gt;
&lt;p&gt;3 CSS3 新增伪类有那些？&lt;/p&gt;
&lt;p&gt;p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p:last-of-type  选择属于其父元素的最后 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。

p:only-of-type  选择属于其父元素唯一的 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。

p:only-child    选择属于其父元素的唯一子元素的每个 &amp;lt;p&amp;gt; 元素。

p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &amp;lt;p&amp;gt; 元素。

:enabled、:disabled 控制表单控件的禁用状态。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:checked，单选框或复选框被选中。&lt;/p&gt;
&lt;p&gt;4 H5+CSS3 兼容性解决的方案&lt;/p&gt;
&lt;p&gt;1 htmlshiv.js 框架 HTML5shiv 通过 JavaScript 来创建 HTML5 元素 (如 main, header, footer 等)&lt;/p&gt;
&lt;!--[if lt IE 9]&gt;

&lt;script&gt; src=&#34;http://html5shim.googlecode.com/svn/trunk/html5.js&#34;&lt;/script&gt;

&lt;![endif]--&gt;
&lt;p&gt;2 selectivizr.js&lt;/p&gt;
&lt;p&gt;selectivizr 是一个 JavaScript 工具，使 IE 浏览器也可以支持 CSS3 伪类以及属性选择器&lt;/p&gt;
&lt;p&gt;使用很简单，只要把 js include 到页面上，然后你就可以&lt;/p&gt;
&lt;script type=&#34;text/javascript&#34; src=&#34;[JS library]&#34;&gt;&lt;/script&gt;
&lt;p&gt;&amp;lt;!- -[if (gte IE 6)&amp;amp;(lte IE 8)]&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;selectivizr.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

  &amp;lt;noscript&amp;gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;[fallback css]&amp;quot; /&amp;gt;&amp;lt;/noscript&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;![endif]- -&amp;gt;&lt;/p&gt;
&lt;p&gt;3 条件注释&lt;/p&gt;
&lt;p&gt;5 CSS3 有哪些新特性？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CSS3 实现圆角（border-radius），阴影（box-shadow），&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3.transform:rotate (9deg) scale (0.85,0.90) translate (0px,-30px) skew (-9deg,0deg);// 旋转，缩放，定位，倾斜&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;增加了更多的 CSS 选择器  多背景 rgba&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 CSS3 中唯一引入的伪元素是 ::selection.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;媒体查询，多栏布局&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;border-image&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JS+JQuery 部分内容&lt;/p&gt;
&lt;p&gt;1 数组和字符串中常用的方法&lt;/p&gt;
&lt;p&gt;1）数组中常用的方法&lt;/p&gt;
&lt;p&gt;Push () 向数组的末尾增加一项  unshift () 向数组开头增加一项&lt;/p&gt;
&lt;p&gt;pop () 删除数组的末尾项       shift () 删除数组开头项&lt;/p&gt;
&lt;p&gt;Splice () 删除数组中的任意项  concat 拼接&lt;/p&gt;
&lt;p&gt;Join () 把数组中的每一项 按照指定的分隔符拼接成字符串&lt;/p&gt;
&lt;p&gt;reverse: 倒序数组 返回值倒序数组 原有数组改变&lt;br&gt;
 sort: 根据匿名函数进行冒泡排序 b-a 倒序 a-b 升序&lt;/p&gt;
&lt;p&gt;兼容性不好：&lt;br&gt;
indexOf: 返回获取项在数组中的索引&lt;br&gt;
 lastIndexOf: 返回获取项在数组中出现的最后一次索引&lt;br&gt;
 forEach: 循环遍历数组 参数是一个匿名函数 默认返回为 undefined&lt;br&gt;
map：循环遍历数组 参数是一个匿名函数&lt;/p&gt;
&lt;p&gt;2）字符串中常用的方法&lt;/p&gt;
&lt;p&gt;substring 方法返回位于 String 对象中指定位置的子字符串。&lt;/p&gt;
&lt;p&gt;substr 方法返回一个从指定位置开始的指定长度的子字符串。&lt;/p&gt;
&lt;p&gt;slice 方法返回字符串的片段。&lt;/p&gt;
&lt;p&gt;split 将一个字符串分割为子字符串，然后将结果作为字符串数组返回。&lt;/p&gt;
&lt;p&gt;2 js 兼容性问题&lt;/p&gt;
&lt;p&gt;1 获取，设置标签的内容 iE 和 chrome 浏览器支持 innerText  火狐浏览器支持 textContent&lt;/p&gt;
&lt;p&gt;2 获取指定元素的第一个元素和最后一个元素  element.firstElementChild&lt;/p&gt;
&lt;p&gt;IE679 只能获取 firstChild 获取第一个字节点，然后通过判断的节点的类型区的第一个子元素&lt;/p&gt;
&lt;p&gt;3event.x 与 event.y，在 IE 中，event 对象有 x,y 属性，现代浏览器中中，与 event.x 等效的是 event.pageX ，但 event.pageX IE 中没有&lt;/p&gt;
&lt;p&gt;4 问题说明：IE 下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute () 获取自定义属性；Firefox 下，只能使用 getAttribute () 获取自定义属性。&lt;/p&gt;
&lt;p&gt;解决方法：统一通过 getAttribute () 获取自定义属性。&lt;/p&gt;
&lt;p&gt;3 说说你对闭包的理解&lt;/p&gt;
&lt;p&gt;可以把闭包简单理解成 “定义在一个函数内部的函数”&lt;/p&gt;
&lt;p&gt;闭包有三个特性：&lt;/p&gt;
&lt;p&gt;1. 函数嵌套函数&lt;/p&gt;
&lt;p&gt;2. 函数内部可以引用外部的参数和变量&lt;/p&gt;
&lt;p&gt;3. 参数和变量不会被垃圾回收机制回收&lt;/p&gt;
&lt;p&gt;由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题&lt;/p&gt;
&lt;p&gt;4、javascript 里面的继承怎么实现，如何避免原型链上面的对象共享&lt;/p&gt;
&lt;p&gt;用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的 extend () 函数，很多前端框架都有封装的，就是用一个空函数当做中间变量&lt;/p&gt;
&lt;p&gt;5、JavaScript 原型，原型链？有什么特点？&lt;/p&gt;
&lt;p&gt;原型对象也是普通的对象，是对象一个自带隐式的 &lt;strong&gt;proto&lt;/strong&gt; 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链。*&lt;/p&gt;
&lt;p&gt;原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。&lt;/p&gt;
&lt;p&gt;6 请说出三种减少页面加载时间的方法。&lt;/p&gt;
&lt;p&gt;1. 优化图片&lt;/p&gt;
&lt;p&gt;2. 图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）&lt;/p&gt;
&lt;p&gt;3. 优化 CSS（压缩合并 css，如 margin-top,margin-left…)&lt;/p&gt;
&lt;p&gt;4. 网址后加斜杠（&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS13d3ctZW84ZS5jYW1wci5jb20vJUU3JTlCJUFFJUU1JUJEJTk1JUVGJUJDJThDJUU0JUJDJTlBJUU1JTg4JUE0JUU2JTk2JUFEJUU4JUJGJTk5JUU0JUI4JUFBJUUyJTgwJTlDJUU3JTlCJUFFJUU1JUJEJTk1JUU2JTk4JUFGJUU0JUJCJTgwJUU0JUI5JTg4JUU2JTk2JTg3JUU0JUJCJUI2JUU3JUIxJUJCJUU1JTlFJThCJUVGJUJDJThDJUU2JTg4JTk2JUU4JTgwJTg1JUU2JTk4JUFGJUU3JTlCJUFFJUU1JUJEJTk1JUUzJTgwJTgyJUVGJUJDJTg5&#34;&gt;如 www.campr.com/ 目录，会判断这个 “目录是什么文件类型，或者是目录。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. 标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。&lt;/p&gt;
&lt;p&gt;当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）&lt;/p&gt;
&lt;p&gt;6. 减少 http 请求（合并文件，合并图片）&lt;/p&gt;
&lt;p&gt;7. 你有哪些性能优化的方法？&lt;/p&gt;
&lt;p&gt;（1） 减少 http 请求次数：CSS Sprites, JS、CSS 源码压缩、图片大小控制合适；网页 Gzip，CDN 托管，data 缓存 ，图片服务器。&lt;/p&gt;
&lt;p&gt;（2） 前端模板 JS + 数据，减少由于 HTML 标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数&lt;/p&gt;
&lt;p&gt;（3） 用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 javascript 性能。&lt;/p&gt;
&lt;p&gt;（4） 当需要设置的样式很多时设置 className 而不是直接操作 style。&lt;/p&gt;
&lt;p&gt;（5） 少用全局变量、缓存 DOM 节点查找的结果。减少 IO 读取操作。&lt;/p&gt;
&lt;p&gt;（6） 避免使用 CSS Expression（css 表达式) 又称 Dynamic properties (动态属性)。&lt;/p&gt;
&lt;p&gt;图片预加载，将样式表放在顶部，将脚本放在底部？加上时间戳。&lt;/p&gt;
&lt;p&gt;8、 平时如何管理你的项目？&lt;/p&gt;
&lt;p&gt;1) 先期团队必须确定好全局样式（globe.css），编码模式 (utf-8) 等；&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3) 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）&lt;/p&gt;
&lt;p&gt;4) 页面进行标注（例如 页面 模块 开始和结束）&lt;/p&gt;
&lt;p&gt;5) CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）；&lt;/p&gt;
&lt;p&gt;6) JS 分文件夹存放 命名以该 JS 功能为准的英文翻译。&lt;/p&gt;
&lt;p&gt;9、call 和 apply 的区别&lt;/p&gt;
&lt;p&gt;call 和 apply 相同点：改变函数中 this 的指向&lt;/p&gt;
&lt;p&gt;不同点：函数参数的传递形式&lt;/p&gt;
&lt;p&gt;call 将函数参数依次传入&lt;/p&gt;
&lt;p&gt;apply 将函数参数用一个数组的形式传入&lt;/p&gt;
&lt;p&gt;10、原生 JS 的 window.onload 与 Jquery 的&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mtext&gt;，&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(document).ready(function() {})，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;(function () {}) 有什么不同？&lt;/p&gt;
&lt;p&gt;1) 执行时间&lt;/p&gt;
&lt;p&gt;window.onload 必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready () 是 DOM 结构绘制完毕后就执行，不必等到加载完毕。&lt;/p&gt;
&lt;p&gt;2) 编写个数不同&lt;/p&gt;
&lt;p&gt;window.onload 不能同时编写多个，如果有多个 window.onload 方法，只会执行一个 $(document).ready () 可以同时编写多个，并且都可以得到执行&lt;/p&gt;
&lt;p&gt;3) 简化写法 window.onload 没有简化写法 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mtext&gt;可以简写成&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(document).ready(function(){})可以简写成&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;可&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;以&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;简&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;写&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;成&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; (function (){})；&lt;/p&gt;
&lt;p&gt;11、split (),join () 的区别？&lt;/p&gt;
&lt;p&gt;split () 方法通过把字符串分割成子字符串来把一个 String 对象分割成一个字符串数组。&lt;/p&gt;
&lt;p&gt;join () 方法将数组中的所有元素连接成一个字符串。&lt;/p&gt;
&lt;p&gt;12、谈一下 Jquery 中的 bind (),live (),delegate (),on () 的区别？&lt;/p&gt;
&lt;p&gt;bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回 jQuery 对象。&lt;/p&gt;
&lt;p&gt;live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回 jQuery 对象。&lt;/p&gt;
&lt;p&gt;delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。&lt;/p&gt;
&lt;p&gt;On: 支持直接在目标元素上绑定事件，也支持在目标元素的祖辈元素上委托绑定。在事件委托绑定模式下，即使是执行 on () 函数之后新添加的元素，只要它符合条件，绑定的事件处理函数也对其有效。&lt;/p&gt;
&lt;p&gt;Ajax 的面试题&lt;/p&gt;
&lt;p&gt;1、解释 jsonp 的原理&lt;/p&gt;
&lt;p&gt;动态创建 script 标签，回调函数&lt;/p&gt;
&lt;p&gt;2、请尽可能详尽的解释 ajax 的工作原理&lt;/p&gt;
&lt;p&gt;思路：先解释异步，再解释 ajax 如何使用&lt;/p&gt;
&lt;p&gt;Ajax 的原理简单来说通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest 有所了解。&lt;/p&gt;
&lt;p&gt;XMLHttpRequest 是 ajax 的核心机制，它是在 IE5 中首先引入的，是一种支持异步请求的技术。简单的说，也就是 javascript 可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。&lt;/p&gt;
&lt;p&gt;3、Ajax 的最大的特点是什么。&lt;/p&gt;
&lt;p&gt;Ajax 可以实现动态不刷新（局部刷新）&lt;/p&gt;
&lt;p&gt;readyState 属性 状态 有 5 个可取值： 0 = 未初始化 ，1 = 启动 2 = 发送，3 = 接收，4 = 完成&lt;/p&gt;
&lt;p&gt;4、ajax 的缺点&lt;/p&gt;
&lt;p&gt;1） ajax 不支持浏览器 back 按钮。&lt;/p&gt;
&lt;p&gt;2) 安全问题 AJAX 暴露了与服务器交互的细节。&lt;/p&gt;
&lt;p&gt;3) 对搜索引擎的支持比较弱。&lt;/p&gt;
&lt;p&gt;4) 破坏了程序的异常机制。&lt;/p&gt;
&lt;p&gt;5) 不容易调试。&lt;/p&gt;
&lt;p&gt;5、get 和 post 的区别？&lt;/p&gt;
&lt;p&gt;GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在 2000 个字符；&lt;/p&gt;
&lt;p&gt;POST：一般用于修改服务器上的资源，对所发送的信息没有限制。&lt;/p&gt;
&lt;p&gt;也就是说 Get 是通过地址栏来传值，而 Post 是通过提交表单来传值。&lt;/p&gt;
&lt;p&gt;6、如何解决跨域问题？&lt;br&gt;
 理解跨域的概念：协议、域名、端口都相同才同域，否则都是跨域&lt;/p&gt;
&lt;p&gt;1.Get 方式请求的跨域可以通过 jsonp 来解决。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy50dWljb29sLmNvbS9hcnRpY2xlcy9RQmJ1aWFS&#34;&gt;http://www.tuicool.com/articles/QBbuiaR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.Post 方式的请求  cors 解决跨域&lt;/p&gt;
&lt;p&gt;Cors 解释&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5jbmJsb2dzLmNvbS9EYXJyZW5fY29kZS9wL2NvcnMuaHRtbA==&#34;&gt;http://www.cnblogs.com/Darren_code/p/cors.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JSONP 实现跨域&lt;/p&gt;
&lt;p&gt;常用的 jquery 实现跨域调用&lt;/p&gt;
&lt;p&gt;$.ajax({&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;url: &amp;quot;http://127.0.0.1/~chenjiebin/mycode/php/crossdomain/index.php&amp;quot;,

dataType: &amp;quot;jsonp&amp;quot;,

jsonp: &amp;quot;callback&amp;quot;,

context: document.body,

success: function(data) &amp;#123;

    console.log(data);

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;这个调用实际上的实现原理是&lt;/p&gt;
&lt;p&gt;在网页中构造一个 script 标签，将 src 设置为对应的 url，并增加上相应的 callback 参数，形如如下格式：&lt;/p&gt;
&lt;script src=&#34;http://127.0.0.1/~chenjiebin/mycode/php/crossdomain/index.php?callback=jQuery211018970995225637144_1465350372062&amp;_=1465350372063&#34;&gt;&lt;/script&gt;
&lt;p&gt;请求的服务端代码如下：&lt;/p&gt;
&lt;p&gt;$data     = json_encode(array(“id” =&amp;gt; “1”, “name” =&amp;gt; “tom”));&lt;/p&gt;
&lt;p&gt;$callback = $_GET[“callback”];&lt;/p&gt;
&lt;p&gt;echo $callback . “(” . $data . “)”;&lt;/p&gt;
&lt;p&gt;实际上最后返回的内容就是一段 js 代码：&lt;/p&gt;
&lt;p&gt;jQuery211018970995225637144_1465350372062({“id”:“1”,“name”:“tom”})&lt;/p&gt;
&lt;p&gt;当浏览器获取到该段 js 代码后就会执行这个函数，从而实现回调 ajax 请求时设置的 success 方法。&lt;/p&gt;
&lt;p&gt;jsonp 实现的缺点&lt;/p&gt;
&lt;p&gt;了解了原理后，就知道 jsonp 实现的跨域方式不支持 post 请求，只能支持 get 请求。但是如果需要支持 post 请求该怎么办呢？下面谈下服务器端设置的方式。&lt;/p&gt;
&lt;p&gt;服务端设置支持跨域&lt;/p&gt;
&lt;p&gt;主要是 Access-Control-Allow-Origin 头参数，该参数用来指定允许哪个来源的域请求。服务端代码如下：&lt;/p&gt;
&lt;p&gt;// 表示支持所有来源的域进行请求&lt;/p&gt;
&lt;p&gt;// 实际在操作过程中可以设置为指定域&lt;/p&gt;
&lt;p&gt;header(‘Access-Control-Allow-Origin:*’);&lt;/p&gt;
&lt;p&gt;$data = json_encode(array(“id” =&amp;gt; “1”, “name” =&amp;gt; “tom”));&lt;/p&gt;
&lt;p&gt;echo $data;&lt;/p&gt;
&lt;p&gt;对应的 js 代码：&lt;/p&gt;
&lt;p&gt;$.ajax({&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type: &amp;quot;POST&amp;quot;,

url: &amp;quot;http://127.0.0.1/~chenjiebin/mycode/php/crossdomain/header.php&amp;quot;,

dataType: &amp;quot;json&amp;quot;,

success: function(data) &amp;#123;

    console.log(data);

&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;可以支持 post 请求&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;                   移动web开发
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1、px，em，rem 的区别？&lt;/p&gt;
&lt;p&gt;1）px 像素（Pixel） 。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px 要换算成物理长度，需要指定精度 DPI。&lt;/p&gt;
&lt;p&gt;2）em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因此并不是一个固定的值。&lt;/p&gt;
&lt;p&gt;3）rem 是 CSS3 新增的一个相对单位（rootem，根 em） ，使用 rem 为元素设定字体大小时，仍然是相对大小，&lt;/p&gt;
&lt;p&gt;但相对的只是 HTML 根元素。&lt;/p&gt;
&lt;p&gt;2、jQuery 和 Zepto 的区别？各自的使用场景？Zepto 比 jQuery 轻量的原因？&lt;/p&gt;
&lt;p&gt;jQuery 主要用于 PC 端开发，Zepto 比 jQuery 更加小巧，主要用于移动端，Zepto 是不兼容低版本的浏览器&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;p&gt;1）Zepto 轻量的原因是没有像 jQuery 一样处理移动端的兼容性问题，&lt;/p&gt;
&lt;p&gt;2）Zepto 的模块是放到不同的模块中，根据业务需要引入模块，减少代码量，提高网页的加载速度&lt;/p&gt;
&lt;p&gt;3、bootstrap 框架中的栅格系统的本质是什么？以及 bootstrap 框架的优缺点？&lt;/p&gt;
&lt;p&gt;bootstrap 的栅格系统的本质是通过 css3 的媒体查询实现的&lt;/p&gt;
&lt;p&gt;优点:bootstrap 框架便于快速布局，而且添加了更加灵活的栅格系统，增加了响应式&lt;/p&gt;
&lt;p&gt;计，来适配不同的设备&lt;/p&gt;
&lt;p&gt;缺点：对 ie678 的兼容性可能不太好，而且 bootstrap 是依赖于 jQuery，代码的体积大，会影响网页的加载速度，不适合移动端。&lt;/p&gt;
&lt;p&gt;4、如何解决移动端的 click 事件的延迟响应？&lt;/p&gt;
&lt;p&gt;移动端 click 屏幕产生 200-300 ms 的延迟响应，往往会造成按钮点击延迟甚至是点击失效。&lt;/p&gt;
&lt;p&gt;解决方案&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响应，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2s=&#34;&gt;https://github.com/ftlabs/fastclick&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2) zepto 的 touch 模块，tap 事件也是为了解决在 click 的延迟问题&lt;/p&gt;
&lt;p&gt;5、什么是 mvc 开发模式？&lt;/p&gt;
&lt;p&gt;Mvc 是一中组织代码结构的方式，便于代码的管理和维护。&lt;/p&gt;
</content>
        <updated>2021-01-21T13:06:14.508Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/01/21/Linux%20interview%20summary/</id>
        <title>Linux interview summary</title>
        <link rel="alternate" href="http://example.com/2021/01/21/Linux%20interview%20summary/"/>
        <content type="html">&lt;h2 id=&#34;常用指令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常用指令&#34;&gt;#&lt;/a&gt; 常用指令&lt;/h2&gt;
&lt;p&gt;ls　　        显示文件或目录&lt;br&gt;
 - l           列出文件详细信息 l (list)&lt;br&gt;
-a          列出当前目录下所有文件及目录，包括隐藏的 a (all)&lt;br&gt;
 mkdir         创建目录&lt;br&gt;
 - p           创建目录，若无父目录，则创建 p (parent)&lt;br&gt;
 cd               切换目录&lt;br&gt;
 touch          创建空文件&lt;br&gt;
 echo            创建带有内容的文件。&lt;br&gt;
cat              查看文件内容&lt;br&gt;
 cp                拷贝&lt;br&gt;
 mv               移动或重命名&lt;br&gt;
 rm               删除文件&lt;br&gt;
 - r            递归删除，可删除子目录及文件&lt;br&gt;
 - f            强制删除&lt;br&gt;
 find              在文件系统中搜索某文件&lt;br&gt;
 wc                统计文本中行数、字数、字符数&lt;br&gt;
 grep             在文本文件中查找某个字符串&lt;br&gt;
 rmdir           删除空目录&lt;br&gt;
 tree             树形结构显示目录，需要安装 tree 包&lt;br&gt;
 pwd              显示当前目录&lt;br&gt;
 ln                  创建链接文件&lt;br&gt;
 more、less  分页显示文本文件内容&lt;br&gt;
 head、tail    显示文件头、尾内容&lt;br&gt;
 ctrl+alt+F1  命令行全屏模式&lt;/p&gt;
&lt;h2 id=&#34;系统管理命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#系统管理命令&#34;&gt;#&lt;/a&gt; 系统管理命令&lt;/h2&gt;
&lt;p&gt;stat              显示指定文件的详细信息，比 ls 更详细&lt;br&gt;
 who               显示在线登陆用户&lt;br&gt;
 whoami          显示当前操作用户&lt;br&gt;
 hostname      显示主机名&lt;br&gt;
 uname           显示系统信息&lt;br&gt;
 top                动态显示当前耗费资源最多进程信息&lt;br&gt;
 ps                  显示瞬间进程状态 ps -aux&lt;br&gt;
du                  查看目录大小 du -h /home 带有单位显示目录信息&lt;br&gt;
 df                  查看磁盘大小 df -h 带有单位显示磁盘信息&lt;br&gt;
 ifconfig          查看网络情况&lt;br&gt;
 ping                测试网络连通&lt;br&gt;
 netstat          显示网络状态信息&lt;br&gt;
 man                命令不会用了，找男人  如：man ls&lt;br&gt;
clear              清屏&lt;br&gt;
 alias               对命令重命名 如：alias showmeit=“ps -aux” ，另外解除使用 unaliax showmeit&lt;br&gt;
kill                 杀死进程，可以先用 ps 或 top 命令查看进程的 id，然后再用 kill 命令杀死进程。&lt;/p&gt;
&lt;h2 id=&#34;打包压缩相关命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#打包压缩相关命令&#34;&gt;#&lt;/a&gt; 打包压缩相关命令&lt;/h2&gt;
&lt;p&gt;gzip：&lt;br&gt;
bzip2：&lt;br&gt;
tar:                打包压缩&lt;br&gt;
 - c              归档文件&lt;br&gt;
 - x              压缩文件&lt;br&gt;
 - z              gzip 压缩文件&lt;br&gt;
 - j              bzip2 压缩文件&lt;br&gt;
 - v              显示压缩或解压缩过程 v (view)&lt;br&gt;
-f              使用档名&lt;br&gt;
例：&lt;br&gt;
tar -cvf /home/abc.tar/home/abc              只打包，不压缩&lt;br&gt;
 tar -zcvf /home/abc.tar.gz/home/abc        打包，并用 gzip 压缩&lt;br&gt;
 tar -jcvf /home/abc.tar.bz2 /home/abc      打包，并用 bzip2 压缩&lt;br&gt;
当然，如果想解压缩，就直接替换上面的命令  tar -cvf  /tar -zcvf  /tar -jcvf 中的 “c” 换成 “x” 就可以了。&lt;/p&gt;
&lt;h2 id=&#34;关机重启机器&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#关机重启机器&#34;&gt;#&lt;/a&gt; 关机 / 重启机器&lt;/h2&gt;
&lt;p&gt;shutdown&lt;br&gt;
-r             关机重启&lt;br&gt;
 - h             关机不重启&lt;br&gt;
 now          立刻关机&lt;br&gt;
 halt               关机&lt;br&gt;
 reboot          重启&lt;/p&gt;
&lt;h2 id=&#34;linux管道&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#linux管道&#34;&gt;#&lt;/a&gt; Linux 管道&lt;/h2&gt;
&lt;p&gt;将一个命令的标准输出作为另一个命令的标准输入。也就是把几个命令组合起来使用，后一个命令除以前一个命令的结果。&lt;br&gt;
例：grep -r “close” /home/* | more       在 home 目录下所有文件中查找，包括 close 的文件，并分页输出。&lt;/p&gt;
&lt;h2 id=&#34;linux软件包管理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#linux软件包管理&#34;&gt;#&lt;/a&gt; Linux 软件包管理&lt;/h2&gt;
&lt;p&gt;dpkg (Debian Package) 管理工具，软件包名以.deb 后缀。这种方法适合系统不能联网的情况下。&lt;br&gt;
比如安装 tree 命令的安装包，先将 tree.deb 传到 Linux 系统中。再使用如下命令安装。&lt;br&gt;
sudo dpkg -i tree_1.5.3-1_i386.deb         安装软件&lt;br&gt;
 sudo dpkg -r tree                                     卸载软件&lt;br&gt;
注：将 tree.deb 传到 Linux 系统中，有多种方式。VMwareTool，使用挂载方式；使用 winSCP 工具等；&lt;br&gt;
APT（Advanced Packaging Tool）高级软件工具。这种方法适合系统能够连接互联网的情况。&lt;/p&gt;
&lt;p&gt;依然以 tree 为例&lt;br&gt;
 sudo apt-get install tree                         安装 tree&lt;br&gt;
sudo apt-get remove tree                       卸载 tree&lt;br&gt;
sudo apt-get update                                 更新软件&lt;br&gt;
 sudo apt-get upgrade&lt;/p&gt;
&lt;p&gt;将.rpm 文件转为.deb 文件&lt;br&gt;
.rpm 为 RedHat 使用的软件格式。在 Ubuntu 下不能直接使用，所以需要转换一下。&lt;br&gt;
sudo alien abc.rpm&lt;/p&gt;
&lt;h2 id=&#34;vim使用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#vim使用&#34;&gt;#&lt;/a&gt; vim 使用&lt;/h2&gt;
&lt;p&gt;vim 三种模式：命令模式、插入模式、编辑模式。使用 ESC 或 i 或：来切换模式。&lt;br&gt;
命令模式下：&lt;br&gt;
:q                      退出&lt;br&gt;
:q!                     强制退出&lt;br&gt;
:wq                   保存并退出&lt;br&gt;
:set number     显示行号&lt;br&gt;
:set nonumber  隐藏行号&lt;br&gt;
 /apache            在文档中查找 apache 按 n 跳到下一个，shift+n 上一个&lt;br&gt;
 yyp                   复制光标所在行，并粘贴&lt;br&gt;
 h (左移一个字符←)、j (下一行↓)、k (上一行↑)、l (右移一个字符→)&lt;/p&gt;
&lt;h2 id=&#34;用户及用户组管理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#用户及用户组管理&#34;&gt;#&lt;/a&gt; 用户及用户组管理&lt;/h2&gt;
&lt;p&gt;/etc/passwd    存储用户账号&lt;br&gt;
 /etc/group       存储组账号&lt;br&gt;
 /etc/shadow    存储用户账号的密码&lt;br&gt;
 /etc/gshadow  存储用户组账号的密码&lt;br&gt;
 useradd 用户名&lt;br&gt;
 userdel 用户名&lt;br&gt;
 adduser 用户名&lt;br&gt;
 groupadd 组名&lt;br&gt;
 groupdel 组名&lt;br&gt;
 passwd root     给 root 设置密码&lt;br&gt;
 su root&lt;br&gt;
su - root&lt;br&gt;
/etc/profile     系统环境变量&lt;br&gt;
 bash_profile     用户环境变量&lt;br&gt;
.bashrc              用户环境变量&lt;br&gt;
 su user              切换用户，加载配置文件.bashrc&lt;br&gt;
su - user            切换用户，加载配置文件 /etc/profile ，加载 bash_profile&lt;/p&gt;
&lt;h2 id=&#34;更改文件的用户及用户组&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#更改文件的用户及用户组&#34;&gt;#&lt;/a&gt; 更改文件的用户及用户组&lt;/h2&gt;
&lt;p&gt;sudo chown [-R] owner[:group] {File|Directory}&lt;br&gt;
 例如：还以 jdk-7u21-linux-i586.tar.gz 为例。属于用户 hadoop，组 hadoop&lt;br&gt;
 要想切换此文件所属的用户及组。可以使用命令。&lt;br&gt;
sudo chown root:root jdk-7u21-linux-i586.tar.gz&lt;/p&gt;
&lt;h2 id=&#34;绝对路径用什么符号表示绝对路径用什么符号表示当前目录-上层目录用什么表示主目录用什么表示-切换目录用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#绝对路径用什么符号表示绝对路径用什么符号表示当前目录-上层目录用什么表示主目录用什么表示-切换目录用什么命令&#34;&gt;#&lt;/a&gt; 绝对路径用什么符号表示绝对路径用什么符号表示？当前目录、上层目录用什么表示？主目录用什么表示？切换目录用什么命令？&lt;/h2&gt;
&lt;p&gt;绝对路径： 如 /etc/init.d&lt;br&gt;
 当前目录和上层目录： ./  …/&lt;br&gt;
 主目录： ~/&lt;br&gt;
 切换目录： cd&lt;/p&gt;
&lt;h2 id=&#34;怎么查看当前进程怎么执行退出怎么查看当前路径&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#怎么查看当前进程怎么执行退出怎么查看当前路径&#34;&gt;#&lt;/a&gt; 怎么查看当前进程？怎么执行退出？怎么查看当前路径？&lt;/h2&gt;
&lt;p&gt;查看当前进程： ps&lt;br&gt;
 执行退出： exit&lt;br&gt;
 查看当前路径： pwd&lt;/p&gt;
&lt;h2 id=&#34;怎么清屏怎么退出当前命令怎么执行睡眠怎么查看当前用户-id查看指定帮助用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#怎么清屏怎么退出当前命令怎么执行睡眠怎么查看当前用户-id查看指定帮助用什么命令&#34;&gt;#&lt;/a&gt; 怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？&lt;/h2&gt;
&lt;p&gt;清屏： clear&lt;br&gt;
 退出当前命令： ctrl+c 彻底退出&lt;br&gt;
执行睡眠 ： ctrl+z 挂起当前进程 fg 恢复后台&lt;br&gt;
查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名&lt;br&gt;
查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser --help 这个告诉你一些常用参数； info adduesr；&lt;/p&gt;
&lt;h2 id=&#34;ls-命令执行什么功能-可以带哪些参数有什么区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ls-命令执行什么功能-可以带哪些参数有什么区别&#34;&gt;#&lt;/a&gt; Ls 命令执行什么功能？ 可以带哪些参数，有什么区别？&lt;/h2&gt;
&lt;p&gt;ls 执行的功能： 列出指定目录中的目录，以及文件&lt;br&gt;
哪些参数以及区别： a 所有文件 l 详细信息，包括大小字节数，可读可写可执行的权限等&lt;/p&gt;
&lt;h2 id=&#34;建立软链接快捷方式以及硬链接的命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#建立软链接快捷方式以及硬链接的命令&#34;&gt;#&lt;/a&gt; 建立软链接 (快捷方式)，以及硬链接的命令。&lt;/h2&gt;
&lt;p&gt;软链接： ln -s slink source&lt;br&gt;
 硬链接： ln link source&lt;/p&gt;
&lt;h2 id=&#34;目录创建用什么命令创建文件用什么命令复制文件用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#目录创建用什么命令创建文件用什么命令复制文件用什么命令&#34;&gt;#&lt;/a&gt; 目录创建用什么命令？创建文件用什么命令？复制文件用什么命令？&lt;/h2&gt;
&lt;p&gt;创建目录： mkdir&lt;br&gt;
 创建文件：典型的如 touch，vi 也可以创建文件，其实只要向一个不存在的文件输出，都会创建文件&lt;br&gt;
复制文件： cp 7. 文件权限修改用什么命令？格式是怎么样的？&lt;br&gt;
文件权限修改： chmod&lt;br&gt;
 格式如下：&lt;br&gt;
chmodu+xfile 给 file 的属主增加执行权限  chmod 751 file 给 file 的属主分配读、写、执行 (7) 的权限，给 file 的所在组分配读、执行 (5) 的权限，给其他用户分配执行 (1) 的权限&lt;br&gt;
 chmodu=rwx,g=rx,o=xfile 上例的另一种形式 chmod =r file 为所有用户分配读权限&lt;br&gt;
 chmod444file 同上例 chmod a-wx,a+r file 同上例&lt;br&gt;
 $ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限&lt;/p&gt;
&lt;h2 id=&#34;查看文件内容有哪些命令可以使用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看文件内容有哪些命令可以使用&#34;&gt;#&lt;/a&gt; 查看文件内容有哪些命令可以使用？&lt;/h2&gt;
&lt;p&gt;vi 文件名 #编辑方式查看，可修改&lt;br&gt;
 cat 文件名 #显示全部文件内容&lt;br&gt;
 more 文件名 #分页显示文件内容&lt;br&gt;
 less 文件名 #与 more 相似，更好的是可以往前翻页&lt;br&gt;
 tail 文件名 #仅查看尾部，还可以指定行数&lt;br&gt;
 head 文件名 #仅查看头部，还可以指定行数&lt;/p&gt;
&lt;h2 id=&#34;随意写文件命令怎么向屏幕输出带空格的字符串比如hello-world&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#随意写文件命令怎么向屏幕输出带空格的字符串比如hello-world&#34;&gt;#&lt;/a&gt; 随意写文件命令？怎么向屏幕输出带空格的字符串，比如”hello world”?&lt;/h2&gt;
&lt;p&gt;写文件命令：vi&lt;br&gt;
 向屏幕输出带空格的字符串:echo hello world&lt;/p&gt;
&lt;h2 id=&#34;终端是哪个文件夹下的哪个文件黑洞文件是哪个文件夹下的哪个命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#终端是哪个文件夹下的哪个文件黑洞文件是哪个文件夹下的哪个命令&#34;&gt;#&lt;/a&gt; 终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？&lt;/h2&gt;
&lt;p&gt;终端  /dev/tty&lt;br&gt;
 黑洞文件  /dev/null&lt;/p&gt;
&lt;h2 id=&#34;移动文件用哪个命令改名用哪个命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#移动文件用哪个命令改名用哪个命令&#34;&gt;#&lt;/a&gt; 移动文件用哪个命令？改名用哪个命令？&lt;/h2&gt;
&lt;p&gt;mv mv&lt;/p&gt;
&lt;h2 id=&#34;复制文件用哪个命令如果需要连同文件夹一块复制呢如果需要有提示功能呢&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#复制文件用哪个命令如果需要连同文件夹一块复制呢如果需要有提示功能呢&#34;&gt;#&lt;/a&gt; 复制文件用哪个命令？如果需要连同文件夹一块复制呢？如果需要有提示功能呢？&lt;/h2&gt;
&lt;p&gt;cp cp -r  ？？？？&lt;/p&gt;
&lt;h2 id=&#34;删除文件用哪个命令如果需要连目录及目录下文件一块删除呢删除空文件夹用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#删除文件用哪个命令如果需要连目录及目录下文件一块删除呢删除空文件夹用什么命令&#34;&gt;#&lt;/a&gt; 删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？&lt;/h2&gt;
&lt;p&gt;rm rm -r rmdir&lt;/p&gt;
&lt;h2 id=&#34;linux-下命令有哪几种可使用的通配符分别代表什么含义&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#linux-下命令有哪几种可使用的通配符分别代表什么含义&#34;&gt;#&lt;/a&gt; Linux 下命令有哪几种可使用的通配符？分别代表什么含义？&lt;/h2&gt;
&lt;p&gt;“？” 可替代单个字符。&lt;br&gt;
“*” 可替代任意多个字符。&lt;br&gt;
方括号 “[charset]” 可替代 charset 集中的任何单个字符，如 [a-z]，[abABC]&lt;/p&gt;
&lt;h2 id=&#34;对一个文件的内容进行统计用什么命令行号-单词数-字节数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#对一个文件的内容进行统计用什么命令行号-单词数-字节数&#34;&gt;#&lt;/a&gt; 对一个文件的内容进行统计用什么命令？(行号、单词数、字节数)&lt;/h2&gt;
&lt;p&gt;wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。&lt;/p&gt;
&lt;h2 id=&#34;grep-命令有什么用-如何忽略大小写-如何查找不含该串的行&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#grep-命令有什么用-如何忽略大小写-如何查找不含该串的行&#34;&gt;#&lt;/a&gt; Grep 命令有什么用？ 如何忽略大小写？ 如何查找不含该串的行？&lt;/h2&gt;
&lt;p&gt;是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。&lt;br&gt;
grep [stringSTRING] filename grep [^string] filename&lt;/p&gt;
&lt;h2 id=&#34;linux-中进程有哪几种状态在-ps-显示出来的信息中分别用什么符号表示的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#linux-中进程有哪几种状态在-ps-显示出来的信息中分别用什么符号表示的&#34;&gt;#&lt;/a&gt; Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？&lt;/h2&gt;
&lt;p&gt;1）、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。&lt;br&gt;
（2）、暂停状态 / 跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态；当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。&lt;br&gt;
“正在被跟踪” 指的是进程暂停下来，等待跟踪它的进程对它进行操作。&lt;br&gt;
（3）、就绪状态：在 run_queue 队列里的状态&lt;br&gt;
（4）、运行状态：在 run_queue 队列里的状态&lt;br&gt;
（5）、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起&lt;br&gt;
（6）、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉&lt;br&gt;
（7）、退出状态&lt;br&gt;
 D 不可中断 Uninterruptible（usually IO）&lt;br&gt;
R 正在运行，或在队列中的进程&lt;br&gt;
 S 处于休眠状态&lt;br&gt;
 T 停止或被追踪&lt;br&gt;
 Z 僵尸进程&lt;br&gt;
 W 进入内存交换（从内核 2.6 开始无效）&lt;br&gt;
X 死掉的进程&lt;/p&gt;
&lt;h2 id=&#34;怎么使一个命令在后台运行&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#怎么使一个命令在后台运行&#34;&gt;#&lt;/a&gt; 怎么使一个命令在后台运行？&lt;/h2&gt;
&lt;p&gt;一般都是使用 &amp;amp; 在命令结尾来让程序自动运行。(命令后可以不追加空格)&lt;/p&gt;
&lt;h2 id=&#34;利用-ps-怎么显示所有的进程-怎么利用-ps-查看指定进程的信息&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#利用-ps-怎么显示所有的进程-怎么利用-ps-查看指定进程的信息&#34;&gt;#&lt;/a&gt; 利用 ps 怎么显示所有的进程？怎么利用 ps 查看指定进程的信息？&lt;/h2&gt;
&lt;p&gt;ps -ef (system v 输出)&lt;br&gt;
 ps -aux bsd 格式输出&lt;br&gt;
 ps -ef | grep pid&lt;/p&gt;
&lt;h2 id=&#34;专门用来查看后台任务的是哪个命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#专门用来查看后台任务的是哪个命令&#34;&gt;#&lt;/a&gt; 专门用来查看后台任务的是哪个命令？&lt;/h2&gt;
&lt;p&gt;job -l&lt;/p&gt;
&lt;h2 id=&#34;把后台任务调到前台执行使用什么命令把停下的后台任务在后台执行起来用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#把后台任务调到前台执行使用什么命令把停下的后台任务在后台执行起来用什么命令&#34;&gt;#&lt;/a&gt; 把后台任务调到前台执行使用什么命令？把停下的后台任务在后台执行起来用什么命令？&lt;/h2&gt;
&lt;p&gt;把后台任务调到前台执行 fg&lt;br&gt;
 把停下的后台任务在后台执行起来 bg&lt;/p&gt;
&lt;p&gt;## 终止进程用什么命令？带什么参数？&lt;br&gt;
kill [-s &amp;lt; 信息名称或编号&amp;gt;][程序] 或 kill [-l &amp;lt; 信息编号 &amp;gt;]&lt;br&gt;
kill-9 pid&lt;/p&gt;
&lt;h2 id=&#34;怎么查看系统支持的所有信号&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#怎么查看系统支持的所有信号&#34;&gt;#&lt;/a&gt; 怎么查看系统支持的所有信号？&lt;/h2&gt;
&lt;p&gt;kill -l&lt;/p&gt;
&lt;h2 id=&#34;搜索文件用什么命令-格式是怎么样的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#搜索文件用什么命令-格式是怎么样的&#34;&gt;#&lt;/a&gt; 搜索文件用什么命令？格式是怎么样的？&lt;/h2&gt;
&lt;p&gt;find &amp;lt;指定目录&amp;gt; &amp;lt; 指定条件 &amp;gt; &amp;lt; 指定动作 &amp;gt;&lt;br&gt;
whereis 加参数与文件名&lt;br&gt;
 locate 只加文件名&lt;br&gt;
 find 直接搜索磁盘，较慢。&lt;br&gt;
find / -name “string*”&lt;/p&gt;
&lt;h2 id=&#34;查看当前谁在使用该主机用什么命令-查找自己所在的终端信息用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看当前谁在使用该主机用什么命令-查找自己所在的终端信息用什么命令&#34;&gt;#&lt;/a&gt; 查看当前谁在使用该主机用什么命令？查找自己所在的终端信息用什么命令？&lt;/h2&gt;
&lt;p&gt;查找自己所在的终端信息：who am i&lt;br&gt;
 查看当前谁在使用该主机：who&lt;/p&gt;
&lt;h2 id=&#34;查看用过的命令列表使用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看用过的命令列表使用什么命令&#34;&gt;#&lt;/a&gt; 查看用过的命令列表使用什么命令？&lt;/h2&gt;
&lt;p&gt;history&lt;/p&gt;
&lt;h2 id=&#34;查看磁盘使用空间使用什么命令-空闲空间呢&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看磁盘使用空间使用什么命令-空闲空间呢&#34;&gt;#&lt;/a&gt; 查看磁盘使用空间使用什么命令？ 空闲空间呢？&lt;/h2&gt;
&lt;p&gt;df -hl&lt;br&gt;
 文件系统 容量 已用 可用 已用 % 挂载点&lt;br&gt;
 Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% /&lt;br&gt;
/dev/hda1 494M 19M 450M 4% /boot&lt;/p&gt;
&lt;h2 id=&#34;查看网络是否连通使用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看网络是否连通使用什么命令&#34;&gt;#&lt;/a&gt; 查看网络是否连通使用什么命令？&lt;/h2&gt;
&lt;p&gt;netstat&lt;/p&gt;
&lt;h2 id=&#34;查看-ip-地址及接口信息使用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看-ip-地址及接口信息使用什么命令&#34;&gt;#&lt;/a&gt; 查看 ip 地址及接口信息使用什么命令？&lt;/h2&gt;
&lt;p&gt;ifconfig&lt;/p&gt;
&lt;h2 id=&#34;查看各类环境变量用什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看各类环境变量用什么命令&#34;&gt;#&lt;/a&gt; 查看各类环境变量用什么命令？&lt;/h2&gt;
&lt;p&gt;查看所有 env&lt;br&gt;
 查看某个，如 home： env $HOME&lt;/p&gt;
&lt;h2 id=&#34;指定命令提示符是通过什么命令&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#指定命令提示符是通过什么命令&#34;&gt;#&lt;/a&gt; 指定命令提示符是通过什么命令？&lt;/h2&gt;
&lt;p&gt;\u：显示当前用户账号&lt;br&gt;
 \h：显示当前主机名&lt;br&gt;
 \W：只显示当前路径最后一个目录&lt;br&gt;
 \w：显示当前绝对路径（当前用户目录会以～代替）&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mtext&gt;：显示当前全路径&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;PWD：显示当前全路径
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mord mathnormal&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;显&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;示&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;当&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;前&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;全&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;路&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;径&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;：显示命令行’&#39;或者’#&#39;符号
\#：下达的第几个命令
\d：代表日期，格式为week day month date，例如：&#34;MonAug1&#34;
\t：显示时间为24小时格式，如：HH：MM：SS
\T：显示时间为12小时格式
\A：显示时间为24小时格式：HH：MM
\v：BASH的版本信息 如export PS1=’[\u@\h\w\#]‘&lt;/p&gt;
&lt;h2 id=&#34;查找命令的可执行文件是去哪查找的-怎么对其进行设置及添加&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查找命令的可执行文件是去哪查找的-怎么对其进行设置及添加&#34;&gt;#&lt;/a&gt; 查找命令的可执行文件是去哪查找的？怎么对其进行设置及添加？&lt;/h2&gt;
&lt;p&gt;whereis [-bfmsu][-B &amp;lt; 目录 &amp;gt;…][-M &amp;lt; 目录 &amp;gt;…][-S &amp;lt; 目录 &amp;gt;…][文件…]&lt;br&gt;
 补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。&lt;br&gt;
-b   只查找二进制文件。&lt;br&gt;
-B &amp;lt;目录&amp;gt; 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。&lt;br&gt;
-m   只查找说明文件。&lt;br&gt;
-M &amp;lt;目录&amp;gt; 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。&lt;br&gt;
-S &amp;lt;目录&amp;gt; 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。&lt;br&gt;
which 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。&lt;br&gt;
-n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。&lt;br&gt;
-p 与 - n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。&lt;br&gt;
-V   显示版本信息&lt;/p&gt;
&lt;h2 id=&#34;对命令进行取别名&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#对命令进行取别名&#34;&gt;#&lt;/a&gt; 对命令进行取别名？&lt;/h2&gt;
&lt;p&gt;alias la=‘ls -a’&lt;/p&gt;
&lt;h2 id=&#34;du-和-df-的定义以及区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#du-和-df-的定义以及区别&#34;&gt;#&lt;/a&gt; du 和 df 的定义，以及区别？&lt;/h2&gt;
&lt;p&gt;du 显示目录或文件的大小&lt;br&gt;
 df 显示每个 &amp;lt;文件&amp;gt; 所在的文件系统的信息，默认是显示所有文件系统。&lt;br&gt;
（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。）&lt;br&gt;
du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。&lt;br&gt;
df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。&lt;/p&gt;
&lt;h2 id=&#34;awk-详解&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#awk-详解&#34;&gt;#&lt;/a&gt; awk 详解。&lt;/h2&gt;
&lt;p&gt;awk ‘{pattern + action}’ {filenames}&lt;br&gt;
#cat /etc/passwd |awk -F ‘:’ ‘{print 1&amp;quot;\t&amp;quot;7}’ //-F 的意思是以’:&#39; 分隔 root /bin/bash&lt;br&gt;
daemon /bin/sh 搜索 /etc/passwd 有 root 关键字的所有行&lt;br&gt;
 #awk -F: ‘/root/’ /etc/passwd root❌0:0:root:/root:/bin/bash&lt;/p&gt;
&lt;h2 id=&#34;给命令绑定一个宏或者按键的时候应该怎么做呢&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#给命令绑定一个宏或者按键的时候应该怎么做呢&#34;&gt;#&lt;/a&gt; 给命令绑定一个宏或者按键的时候，应该怎么做呢？&lt;/h2&gt;
&lt;p&gt;可以使用 bind 命令，bind 可以很方便地在 shell 中实现宏或按键的绑定。&lt;br&gt;
在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。&lt;br&gt;
比如获取 F12 的字符序列获取方法如下：先按下 Ctrl+V, 然后按下 F12 . 我们就可以得到 F12 的字符序列 ^[[24~。&lt;br&gt;
接着使用 bind 进行绑定。&lt;br&gt;
[root@localhost ~]# bind ‘”\e[24~&amp;quot;:“date”’&lt;br&gt;
注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。&lt;br&gt;
【附】也可以使用 showkey -a 命令查看按键对应的字符序列。&lt;/p&gt;
&lt;h2 id=&#34;显示当前系统支持的所有命令的列表他需要怎么做&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#显示当前系统支持的所有命令的列表他需要怎么做&#34;&gt;#&lt;/a&gt; 显示当前系统支持的所有命令的列表，他需要怎么做？&lt;/h2&gt;
&lt;p&gt;使用命令 compgen ­-c，可以打印出所有支持的命令列表。&lt;br&gt;
[root@localhost ~]$ compgen -c&lt;/p&gt;
&lt;h2 id=&#34;打印出当前的目录栈你会建议他怎么做&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#打印出当前的目录栈你会建议他怎么做&#34;&gt;#&lt;/a&gt; 打印出当前的目录栈，你会建议他怎么做？&lt;/h2&gt;
&lt;p&gt;使用 Linux 命令 dirs 可以将当前的目录栈打印出来。&lt;br&gt;
[root@localhost ~]# dirs&lt;br&gt;
/usr/share/X11&lt;br&gt;
【附】：目录栈通过 pushd popd 来操作。&lt;/p&gt;
&lt;h2 id=&#34;系统在多任务运行时不重启机器的条件下把所有正在运行的进程移除&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#系统在多任务运行时不重启机器的条件下把所有正在运行的进程移除&#34;&gt;#&lt;/a&gt; 系统在多任务运行时不重启机器的条件下，把所有正在运行的进程移除？&lt;/h2&gt;
&lt;p&gt;使用 linux 命令 ’disown -r ’可以将所有正在运行的进程移除。&lt;/p&gt;
&lt;h2 id=&#34;bash-shell-中的hash-命令有什么作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#bash-shell-中的hash-命令有什么作用&#34;&gt;#&lt;/a&gt; bash shell 中的 hash 命令有什么作用？&lt;/h2&gt;
&lt;p&gt;linux 命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径，用该命令可以打印出你所使用过的命令以及执行的次数。&lt;br&gt;
[root@localhost ~]# hash&lt;br&gt;
hits command&lt;br&gt;
2 /bin/ls&lt;br&gt;
2 /bin/su&lt;/p&gt;
&lt;h2 id=&#34;哪一个bash内置命令能够进行数学运算&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哪一个bash内置命令能够进行数学运算&#34;&gt;#&lt;/a&gt; 哪一个 bash 内置命令能够进行数学运算。&lt;/h2&gt;
&lt;p&gt;bash shell 的内置命令 let 可以进行整型数的数学运算。&lt;br&gt;
#! /bin/bash&lt;br&gt;
…&lt;br&gt;
…&lt;br&gt;
let c=a+b&lt;br&gt;
…&lt;br&gt;
…&lt;/p&gt;
&lt;h2 id=&#34;一页一页地查看一个大文件的内容&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一页一页地查看一个大文件的内容&#34;&gt;#&lt;/a&gt; 一页一页地查看一个大文件的内容&lt;/h2&gt;
&lt;p&gt;通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.&lt;br&gt;
[root@localhost ~]# cat file_name.txt | more&lt;/p&gt;
&lt;h2 id=&#34;数据字典属于哪一个用户的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数据字典属于哪一个用户的&#34;&gt;#&lt;/a&gt; 数据字典属于哪一个用户的？&lt;/h2&gt;
&lt;p&gt;数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的&lt;/p&gt;
&lt;h2 id=&#34;查看一个linux命令的概要与用法假设你在bin目录中偶然看到一个你从没见过的的命令怎样才能知道它的作用和用法呢&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看一个linux命令的概要与用法假设你在bin目录中偶然看到一个你从没见过的的命令怎样才能知道它的作用和用法呢&#34;&gt;#&lt;/a&gt; 查看一个 linux 命令的概要与用法？假设你在 /bin 目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？&lt;/h2&gt;
&lt;p&gt;使用命令 whatis 可以先出显示出这个命令的用法简要，比如，你可以使用 whatis zcat 去查看‘zcat’的介绍以及使用简要。&lt;br&gt;
[root@localhost ~]# whatis zcat&lt;br&gt;
zcat [gzip] (1) – compress or expand files&lt;/p&gt;
&lt;h2 id=&#34;查看自己文件系统的磁盘空间配额呢&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查看自己文件系统的磁盘空间配额呢&#34;&gt;#&lt;/a&gt; 查看自己文件系统的磁盘空间配额呢？&lt;/h2&gt;
&lt;p&gt;使用命令 repquota 能够显示出一个文件系统的配额信息&lt;br&gt;
【附】只有 root 用户才能够查看其它用户的配额。&lt;/p&gt;
&lt;h2 id=&#34;root用户&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#root用户&#34;&gt;#&lt;/a&gt; root 用户&lt;/h2&gt;
&lt;p&gt;root 存在于 UNIX 系统（如 AIX、BSD 等）和类 UNIX 系统（如 Debian、Redhat、Ubuntu 等版本的 Linux 系统以及 Android 系统）中，超级用户一般命名为 root，相当于 Windows 系统中的 system 用户。&lt;/p&gt;
</content>
        <updated>2021-01-21T09:30:38.267Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/01/20/SQL%20interview%20summary/</id>
        <title>SQL interview summary</title>
        <link rel="alternate" href="http://example.com/2021/01/20/SQL%20interview%20summary/"/>
        <content type="html">&lt;h2 id=&#34;一-第一-第二-第三范式之间的理解&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一-第一-第二-第三范式之间的理解&#34;&gt;#&lt;/a&gt; 一、第一、第二、第三范式之间的理解&lt;/h2&gt;
&lt;p&gt;第一范式（1NF）无重复的列&lt;br&gt;
　　所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。&lt;/p&gt;
&lt;a id=&#34;more&#34;&gt;&lt;/a&gt;
&lt;p&gt;1NF 的定义为：符合 1NF 的关系中的每个属性都不可再分&lt;br&gt;
说明：在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。&lt;/p&gt;
&lt;p&gt;第二范式（2NF）属性完全依赖于主键&lt;br&gt;
　　第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。例如员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。&lt;br&gt;
第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是属性完全依赖于主键。&lt;/p&gt;
&lt;p&gt;第三范式（3NF）&lt;br&gt;
　　满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。 也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合 3NF 的要求。&lt;/p&gt;
</content>
        <updated>2021-01-20T07:50:35.342Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/01/17/Java%20interview%20summary/</id>
        <title>Java interview summary</title>
        <link rel="alternate" href="http://example.com/2021/01/17/Java%20interview%20summary/"/>
        <content type="html">&lt;h2 id=&#34;jre与jdk&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#jre与jdk&#34;&gt;#&lt;/a&gt; JRE 与 JDK&lt;/h2&gt;
&lt;p&gt;JRE： Java Runtime Environment&lt;br&gt;
JDK：Java Development Kit&lt;br&gt;
JRE 是 java 运行时环境，包含了 java 虚拟机，java 基础类库。是使用 java 语言编写的程序运行所需要的软件环境，是提供给想运行 java 程序的用户使用的。&lt;br&gt;
JDK 是 java 开发工具包，&lt;/p&gt;
&lt;a id=&#34;more&#34;&gt;&lt;/a&gt;
&lt;p&gt;是程序员使用 java 语言编写 java 程序所需的开发工具包，是提供给程序员使用的。JDK 包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具：jconsole，jvisualvm 等工具软件，还包含了 java 程序编写所需的文档和 demo 例子程序。如果你需要运行 java 程序，只需安装 JRE 就可以了。如果你需要编写 java 程序，需要安装 JDK。&lt;/p&gt;
&lt;h2 id=&#34;形参和实参&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#形参和实参&#34;&gt;#&lt;/a&gt; 形参和实参&lt;/h2&gt;
&lt;p&gt;形参：全称为 &amp;quot;形式参数&amp;quot; 是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传如的参数.&lt;br&gt;
 实参：全称为 &amp;quot;实际参数&amp;quot; 是在调用时传递个该函数的参数.&lt;/p&gt;
&lt;h2 id=&#34;java四类八种基本数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#java四类八种基本数据类型&#34;&gt;#&lt;/a&gt; java 四类八种基本数据类型&lt;/h2&gt;
&lt;p&gt;第一类：整型 byte short int long&lt;br&gt;
 第二类：浮点型 float double&lt;br&gt;
 第三类：逻辑型 boolean (它只有两个值可取 true false)&lt;br&gt;
 第四类：字符型 char&lt;br&gt;
byte (位)                     占用 1 字节&lt;br&gt;
 short (短整数)             占用 2 字节&lt;br&gt;
 int (整数)                    占用 4 字节&lt;br&gt;
 long (长整数)              占用 8 字节&lt;br&gt;
 float (单精度)              占用 4 字节&lt;br&gt;
 double (双精度)          占用 8 字节&lt;br&gt;
 char (字符)                 占用 2 字节&lt;br&gt;
 boolean (布尔值)        占用 1/8 字节&lt;/p&gt;
&lt;h2 id=&#34;java创建对象的四种方式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#java创建对象的四种方式&#34;&gt;#&lt;/a&gt; java 创建对象的四种方式？&lt;/h2&gt;
&lt;p&gt;使用 new 创建对象、运用反射手段、调用对象的 clone () 方法、运用反序列化手段&lt;/p&gt;
&lt;h2 id=&#34;面向对象的特征有哪些方面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#面向对象的特征有哪些方面&#34;&gt;#&lt;/a&gt; 面向对象的特征有哪些方面？&lt;/h2&gt;
&lt;p&gt;①　封装&lt;br&gt;
最常见的是把属性私有化封装在一个类里面，只能通过方法去访问&lt;br&gt;
②　继承&lt;br&gt;
子类继承父类，从而继承了父类的方法和属性&lt;br&gt;
③　抽象&lt;br&gt;
比如一个英雄类，抽象出了 name,hp 这些属性，使得开发过程中更加易于理解&lt;br&gt;
④　多态&lt;br&gt;
多态分操作符的多态和类的多态。 类的多态指父类引用指向子类对象，并且有继承，有重写。&lt;/p&gt;
&lt;h2 id=&#34;重载和重写的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#重载和重写的区别&#34;&gt;#&lt;/a&gt; 重载和重写的区别？&lt;/h2&gt;
&lt;p&gt;重载指的是在同一个类里面，方法名一样，但是参数不一样&lt;br&gt;
重写指的是子类继承了父类的某个方法后，重新又写了一遍&lt;/p&gt;
&lt;h2 id=&#34;final修饰类&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#final修饰类&#34;&gt;#&lt;/a&gt; final 修饰类:&lt;/h2&gt;
&lt;p&gt;final 修饰类即表示此类已经是 “最后的、最终的” 含义。因此，用 final 修饰的类不能被继承，即不能拥有自己的子类。&lt;/p&gt;
&lt;h2 id=&#34;队列&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#队列&#34;&gt;#&lt;/a&gt; 队列&lt;/h2&gt;
&lt;p&gt;队列（queue）是一种采用先进先出 (FIFO) 策略的抽象数据结构，它的想法来自于生活中排队的策略。顾客在付款结账的时候，按照到来的先后顺序排队结账，先来的顾客先结账，后来的顾客后结账。&lt;/p&gt;
&lt;h2 id=&#34;栈&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#栈&#34;&gt;#&lt;/a&gt; 栈&lt;/h2&gt;
&lt;p&gt;栈是一种操作受限的线性表只允许从一端插入和删除数据。栈有两种存储方式，即线性存储和链接存储（链表）。栈的一个最重要的特征就是栈的插入和删除只能在栈顶进行，所以每次删除的元素都是最后进栈的元素，故栈也被称为后进先出（LIFO）表。每个栈都有一个栈顶指针，它初始值为 - 1，且总是指向最后一个入栈的元素，栈有两种处理方式，即进栈（push）和出栈（pop），因为在进栈只需要移动一个变量存储空间，所以它的时间复杂度为 O (1)，但是对于出栈分两种情况，栈未满时，时间复杂度也为 O (1)，但是当栈满时，需要重新分配内存，并移动栈内所有数据，所以此时的时间复杂度为 O (n)。以下举例栈结构的两种实现方式，线性存储和链接存储。&lt;/p&gt;
&lt;h2 id=&#34;多继承与多态&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多继承与多态&#34;&gt;#&lt;/a&gt; 多继承与多态&lt;/h2&gt;
&lt;p&gt;多继承即一个子类可以有多个父类，它继承了多个父类的特性。&lt;br&gt;
多继承可以看作是单继承的扩展。所谓多继承是指派生类具有多个基类，派生类与每个基类之间的关系仍可看作是一个单继承。&lt;br&gt;
多态允许将子类类型的指针赋值给父类类型的指针。&lt;/p&gt;
&lt;h2 id=&#34;虚函数与纯虚函数&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#虚函数与纯虚函数&#34;&gt;#&lt;/a&gt; 虚函数与纯虚函数&lt;/h2&gt;
&lt;p&gt;虚函数是指一个类中你希望重载的成员函数，当你用一个基类指针或引用指向一个继承类对象的时候，你调用一个虚函数，实际调用的是继承类的版本。&lt;br&gt;
有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。&lt;br&gt;
定义纯虚函数就是为了让基类不可实例化化，&lt;br&gt;
 因为实例化这样的抽象数据结构本身并没有意义.&lt;/p&gt;
&lt;h2 id=&#34;序列化和反序列化的定义&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#序列化和反序列化的定义&#34;&gt;#&lt;/a&gt; 序列化和反序列化的定义：&lt;/h2&gt;
&lt;p&gt;(1) Java 序列化就是指把 Java 对象转换为字节序列的过程&lt;br&gt;
 Java 反序列化就是指把字节序列恢复为 Java 对象的过程。&lt;br&gt;
(2) 序列化最重要的作用：在传递和保存对象时。保证对象的完整性和可传递性。对象转换为有序字节流，以便在网络上传输或者保存在本地文件中。&lt;br&gt;
反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。&lt;br&gt;
总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息）&lt;/p&gt;
&lt;h2 id=&#34;二叉树的常用性质&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#二叉树的常用性质&#34;&gt;#&lt;/a&gt; 二叉树的常用性质&lt;/h2&gt;
&lt;h3 id=&#34;常用性质&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常用性质&#34;&gt;#&lt;/a&gt; 常用性质&lt;/h3&gt;
&lt;p&gt;&amp;lt;1&amp;gt;. 在二叉树的第 i 层上最多有 2^(i-1) 个节点 。（i&amp;gt;=1）&lt;br&gt;
&amp;lt;2&amp;gt;. 二叉树中如果深度为 k (有 k 层), 那么最多有 2^k-1 个节点。(k&amp;gt;=1）&lt;br&gt;
&amp;lt;3&amp;gt;. 若二叉树按照从上到下从左到右依次编号，则若某节点编号为 k，则其左右子树根节点编号分别为 2k 和 2k+1;&lt;br&gt;
&amp;lt;4&amp;gt;. 二叉树分类：满二叉树，完全二叉树&lt;br&gt;
满二叉树：高度为 h，由 2^h-1 个节点构成的二叉树称为满二叉树。&lt;/p&gt;
&lt;h3 id=&#34;遍历&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#遍历&#34;&gt;#&lt;/a&gt; 遍历&lt;/h3&gt;
&lt;p&gt;先序遍历：按照根节点 -&amp;gt; 左子树 -&amp;gt; 右子树的顺序访问二叉树&lt;br&gt;
先序遍历：（1）访问根节点；（2）采用先序递归遍历左子树；（3）采用先序递归遍历右子树；&lt;br&gt;
中序遍历：按照左子树 -&amp;gt; 根节点 -&amp;gt; 右子树的顺序访问&lt;br&gt;
中序遍历：（1）采用中序遍历左子树；（2）访问根节点；（3）采用中序遍历右子树&lt;br&gt;
后序遍历：按照左子树 -&amp;gt; 右子树–&amp;gt; 根节点的顺序访问&lt;br&gt;
后序遍历：（1）采用后序递归遍历左子树；（2）采用后序递归遍历右子树；（3）访问根节点；&lt;/p&gt;
&lt;h3 id=&#34;treenode-a-new-treenode1&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#treenode-a-new-treenode1&#34;&gt;#&lt;/a&gt; TreeNode a = new TreeNode(1);&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    TreeNode b = new TreeNode(2);
    TreeNode c = new TreeNode(3);
    TreeNode d = new TreeNode(4);
    TreeNode e = new TreeNode(5);
    TreeNode f = new TreeNode(6);
    TreeNode g = new TreeNode(7);
    a.left = b;
    a.right = c;
    b.right = d;
    c.left = e;
    c.right = f;
    f.left = g;
    System.out.print(&amp;quot;recursivePreOrder: &amp;quot;);
    recursivePreOrder(a);
    System.out.print(&#39;\n&#39; + &amp;quot;recursiveInOrder: &amp;quot;);
    recursiveInOrder(a);----------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;List&amp;lt;List&lt;Integer&gt;&amp;gt; lists = recursiveLevelOrderBottom(a);&lt;br&gt;
for (List&lt;Integer&gt; list : lists) {&lt;br&gt;
for (int p : list) {&lt;br&gt;
System.out.print(p + &amp;quot; &amp;quot;);           }&lt;br&gt;
System.out.println();}}&lt;br&gt;
public static void visit(TreeNode p) {&lt;br&gt;
System.out.print(p.val + &amp;quot; &amp;quot;);    }&lt;/p&gt;
&lt;h3 id=&#34;递归的先序遍历&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#递归的先序遍历&#34;&gt;#&lt;/a&gt; 递归的先序遍历 **********&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public static void recursivePreOrder(TreeNode p) &amp;#123;
    if (p == null) return;
    visit(p);
    recursivePreOrder(p.left);
    recursivePreOrder(p.right);   &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;递归的中序遍历&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#递归的中序遍历&#34;&gt;#&lt;/a&gt; 递归的中序遍历 **********&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public static void recursiveInOrder(TreeNode p) &amp;#123;
    if (p == null) return;
    recursiveInOrder(p.left);
    visit(p);
    recursiveInOrder(p.right);    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;递归的后序遍历&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#递归的后序遍历&#34;&gt;#&lt;/a&gt; 递归的后序遍历 **********&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;public static void recursivePostOrder(TreeNode p) &amp;#123;
    if (p == null) return;
    recursivePostOrder(p.left);
    recursivePostOrder(p.right);
    visit(p);    &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;排序&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#排序&#34;&gt;#&lt;/a&gt; 排序：&lt;/h2&gt;
&lt;h3 id=&#34;冒泡排序稳定时间复杂度onon2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#冒泡排序稳定时间复杂度onon2&#34;&gt;#&lt;/a&gt; 冒泡排序（稳定）：时间复杂度 O (n)–O (n^2)&lt;/h3&gt;
&lt;h3 id=&#34;快速排序不时间复杂度onlgnon2-通过一趟排序将要排序的数据分割成独立的两部分其中一部分的所有数据都比另外一部分的所有数据都要小然后再按此方法对这两部分数据分别进行快速排序整个排序过程可以递归进行以此达到整个数据变成有序序列&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#快速排序不时间复杂度onlgnon2-通过一趟排序将要排序的数据分割成独立的两部分其中一部分的所有数据都比另外一部分的所有数据都要小然后再按此方法对这两部分数据分别进行快速排序整个排序过程可以递归进行以此达到整个数据变成有序序列&#34;&gt;#&lt;/a&gt; 快速排序（不）：时间复杂度 O (nlgn)–O (n^2)。通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/h3&gt;
&lt;p&gt;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
&lt;h3 id=&#34;选择排序不时间复杂度on2-它的工作原理是每一次从待排序的数据元素中选出最小或最大的一个元素存放在序列的起始位置直到全部待排序的数据元素排完-选择排序是不稳定的排序方法比如序列5-5-3第一次就将第一个5与3交换导致第一个5挪动到第二个5后面&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#选择排序不时间复杂度on2-它的工作原理是每一次从待排序的数据元素中选出最小或最大的一个元素存放在序列的起始位置直到全部待排序的数据元素排完-选择排序是不稳定的排序方法比如序列5-5-3第一次就将第一个5与3交换导致第一个5挪动到第二个5后面&#34;&gt;#&lt;/a&gt; 选择排序（不）：时间复杂度 O (n^2)。它的工作原理是每一次从待排序的数据元素中选出最小 (或最大) 的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法 (比如序列 [5， 5， 3] 第一次就将第一个 [5] 与 [3] 交换，导致第一个 5 挪动到第二个 5 后面)。&lt;/h3&gt;
&lt;h3 id=&#34;插入排序稳定入排序的基本操作就是将一个数据插入到已经排好序的有序数据中从而得到一个新的-个数加一的有序数据算法适用于少量数据的排序时间复杂度为onon2-是稳定的排序方法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#插入排序稳定入排序的基本操作就是将一个数据插入到已经排好序的有序数据中从而得到一个新的-个数加一的有序数据算法适用于少量数据的排序时间复杂度为onon2-是稳定的排序方法&#34;&gt;#&lt;/a&gt; 插入排序（稳定）：入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为 O (n)–O (n^2)。是稳定的排序方法。&lt;/h3&gt;
&lt;p&gt;算法描述&lt;br&gt;
⒈ 从第一个元素开始，该元素可以认为已经被排序&lt;br&gt;
⒉ 取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;br&gt;
⒊ 如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;br&gt;
⒋ 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置&lt;br&gt;
⒌ 将新元素插入到下一位置中&lt;br&gt;
⒍ 重复步骤 2&lt;/p&gt;
&lt;p&gt;如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找排序。&lt;/p&gt;
&lt;h3 id=&#34;希尔排序不间隔为增量跳跃取数据on125&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#希尔排序不间隔为增量跳跃取数据on125&#34;&gt;#&lt;/a&gt; 希尔排序（不）：间隔为增量跳跃取数据–O (n^1.25)&lt;/h3&gt;
&lt;h2 id=&#34;哈希查找&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哈希查找&#34;&gt;#&lt;/a&gt; 哈希查找&lt;/h2&gt;
&lt;p&gt;step1 取数据元素的关键字 key，计算其哈希函数值。若该地址对应的存储&lt;br&gt;
空间还没有被占用，则将该元素存入；否则执行 step2 解决冲突。&lt;br&gt;
step2 根据选择的冲突处理方法，计算关键字 key 的下一个存储地址。若下一个存储地址仍被占用，则继续执行 step2，直到找到能用的存储地址为止。&lt;/p&gt;
&lt;p&gt;哈希查找步骤为:&lt;br&gt;
 设哈希表为 HST [0~M-1]，哈希函数取 H (key)，解决冲突的方法为 R (x);&lt;br&gt;
Step1 对给定 k 值，计算哈希地址 Di=H (k); 若 HST 为空，则查找失败；&lt;br&gt;
 若 HST=k，则查找成功；否则，执行 step2 (处理冲突)。&lt;br&gt;
Step2 重复计算处理冲突的下一个存储地址 Dk=R (Dk-1)，直到 HST [Dk] 为&lt;br&gt;
空，或 HST [Dk]=k 为止。若 HST [Dk]=K，则查找成功，否则查找失败。&lt;/p&gt;
&lt;p&gt;哈希查找的本质是先将数据映射成它的哈希值。哈希查找的核心是构造一个哈希函数，它将原来直观、整洁的数据映射为看上去似乎是随机的一些整数。&lt;/p&gt;
&lt;p&gt;哈希查找的产生有这样一种背景–有些数据本身是无法排序的 (如图像)，有些数据是很难比较的 (如图像)。如果数据本身是无法排序的，就不能对它们进行比较查找。如果数据是很难比较的，即使采用折半查找，要比较的次数也是非常多的。因此，哈希查找并不查找数据本身，而是先将数据映射为一个整数 (它的哈希值)，并将哈希值相同的数据存放在同一个位置一即以哈希值为索引构造一个数组。&lt;/p&gt;
&lt;p&gt;在哈希查找的过程中，只需先将要查找的数据映射为它的哈希值，然后查找具有这个哈希值的数据，这就大大减少了查找次数。如果构造哈希函数的参数经过精心设计，内存空间也足以存放哈希表，查找一个数据元素所需的比较次数基本上就接近于一次。&lt;/p&gt;
&lt;h2 id=&#34;算法-最短路径&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#算法-最短路径&#34;&gt;#&lt;/a&gt; 算法 最短路径&lt;/h2&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtMjY1NDgyMzctaWQtMzgzNDUxNC5odG1s&#34;&gt;http://blog.chinaunix.net/uid-26548237-id-3834514.html&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;银行家算法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#银行家算法&#34;&gt;#&lt;/a&gt; 银行家算法&lt;/h2&gt;
&lt;p&gt;银行家算法是一种最有代表性的避免死锁的算法。&lt;br&gt;
要解释银行家算法，必须先解释操作系统安全状态和不安全状态。&lt;br&gt;
安全状态：如果存在一个由系统中所有进程构成的安全序列 P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。&lt;br&gt;
不安全状态：不存在一个安全序列。不安全状态不一定导致死锁。&lt;br&gt;
算法思想：&lt;br&gt;
操作系统按照银行家制定的规则为进程分配资源，当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。&lt;/p&gt;
&lt;h2 id=&#34;dao层到底是做什么的service和dao层有什么关系说得具体一些&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#dao层到底是做什么的service和dao层有什么关系说得具体一些&#34;&gt;#&lt;/a&gt; Dao 层到底是做什么的？service 和 Dao 层有什么关系？说得具体一些。&lt;/h2&gt;
&lt;p&gt;Dao 层是和数据库打交道的，Service 层会封装具体的业务。有点抽象…&lt;br&gt;
dao 封装了用户的增删改查。而业务上要求批量删除用户，Service 就可以封装出一个批量删除用户的功能，但是实现只是循环调用 dao 的单个删除&lt;br&gt;
 Service 封装具体的业务，dao 只是封装基本的数据库元操作。这样 dao 就可以做到尽可能的 “轻”，而 Service 又避免了与具体数据库的关联。当系统要迁移到其他数据库的时候，只需要实现一个相应的 dao 就可以了！&lt;/p&gt;
&lt;h2 id=&#34;java-中-io-流分为几种&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#java-中-io-流分为几种&#34;&gt;#&lt;/a&gt; java 中 IO 流分为几种？&lt;/h2&gt;
&lt;p&gt;按功能来分：输入流（input）、输出流（output）。&lt;br&gt;
按类型来分：字节流和字符流。&lt;br&gt;
字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。&lt;/p&gt;
&lt;p&gt;访问修饰符 public、private、protected、default 在应用设计中的作用&lt;br&gt;
 public           所有类可见&lt;br&gt;
 protected      	 本包和所有子类都可见（本包中的子类非子类均可访问，不同包中的子类可以访问，不是子类不能访问）&lt;br&gt;
default          本包可见（即默认的形式）（本包中的子类非子类均可访问，不同包中的类及子类均不能访问）&lt;br&gt;
priavte          本类可见&lt;/p&gt;
&lt;p&gt;public： Java 语言中访问限制最宽的修饰符，一般称之为 “公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。&lt;br&gt;
private: Java 语言中对访问权限限制的最窄的修饰符，一般称之为 “私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。&lt;br&gt;
protect: 介于 public 和 private 之间的一种访问修饰符，一般称之为 “保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。&lt;br&gt;
default：即不加任何访问修饰符，通常称为 &amp;quot;默认访问模式&amp;quot;。该模式下，只允许在同一个包中进行访问。&lt;/p&gt;
&lt;h2 id=&#34;和的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#和的区别&#34;&gt;#&lt;/a&gt; &amp;amp; 和 &amp;amp;&amp;amp; 的区别？&lt;/h2&gt;
&lt;p&gt;&amp;amp; 有两个作用，分别是 位与 和 逻辑与&lt;br&gt;
 &amp;amp;&amp;amp; 就是逻辑与&lt;br&gt;
作为逻辑与， &amp;amp; 和 &amp;amp;&amp;amp; 分别表示长路与和短路与&lt;br&gt;
长路与 两侧，都会被运算&lt;br&gt;
短路与 只要第一个是 false，第二个就不进行运算了&lt;/p&gt;
&lt;h2 id=&#34;常见的集合有哪些&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#常见的集合有哪些&#34;&gt;#&lt;/a&gt; 常见的集合有哪些？&lt;/h2&gt;
&lt;p&gt;Map 接口和 Collection 接口是所有集合框架的父接口&lt;br&gt;
 Collection 接口的子接口包括：Set 接口和 List 接口&lt;br&gt;
 Map（保存数据的方式是键值对）接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap 以及 Properties 等&lt;br&gt;
 Set（是无序的，不可以重复）接口的实现类主要有：HashSet、TreeSet、LinkedHashSet 等&lt;br&gt;
 List（是有顺序的，并且可以重复）接口的实现类主要有：ArrayList、LinkedList、Stack 以及 Vector 等&lt;/p&gt;
&lt;h2 id=&#34;哪些集合类是线程安全的&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#哪些集合类是线程安全的&#34;&gt;#&lt;/a&gt; 哪些集合类是线程安全的？&lt;/h2&gt;
&lt;p&gt;vector：就比 arraylist 多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在 web 应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。&lt;br&gt;
statck：堆栈类，先进后出。&lt;br&gt;
hashtable：就比 hashmap 多了个线程安全。&lt;br&gt;
enumeration：枚举，相当于迭代器。&lt;/p&gt;
&lt;h2 id=&#34;抽象类和接口的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#抽象类和接口的区别&#34;&gt;#&lt;/a&gt; 抽象类和接口的区别？&lt;/h2&gt;
&lt;p&gt;使用方式： 抽象类只能够通过继承被使用；接口必须通过实现被使用&lt;br&gt;
实现方法：抽象类不仅可以提供抽象方法，也可以提供实现方法；接口只能提供抽象方法，不能提供实现方法。 但是在 JAVA8 版本开始，接口可以提供实现方法了，前提是要在方法前加一个 default 修饰符&lt;br&gt;
接口可以可继承接口（比如 List 就继承了接口 Collection）&lt;br&gt;
抽象类可以实现 (implements) 接口（比如 MouseAdapter 鼠标监听适配器 是一个抽象类，并且实现了 MouseListener 接口）&lt;br&gt;
抽象类可以继承实体类（所有抽象类，都继承了 Object）&lt;/p&gt;
&lt;h2 id=&#34;hashmap与hashtable的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#hashmap与hashtable的区别&#34;&gt;#&lt;/a&gt; HashMap 与 HashTable 的区别？&lt;/h2&gt;
&lt;p&gt;区别 1： HashMap 可以存放 null      Hashtable 不能存放 null&lt;br&gt;
 区别 2：HashMap 不是线程安全的类   Hashtable 是线程安全的类&lt;/p&gt;
&lt;h2 id=&#34;array-和-arraylist-有何区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#array-和-arraylist-有何区别&#34;&gt;#&lt;/a&gt; Array 和 ArrayList 有何区别？&lt;/h2&gt;
&lt;p&gt;Array 可以容纳基本类型和对象，而 ArrayList 只能容纳对象。&lt;br&gt;
Array 是指定大小的，而 ArrayList 初始大小是固定的。&lt;br&gt;
Array 没有提供 ArrayList 那么多功能，比如 addAll、removeAll 和 iterator 等。&lt;/p&gt;
&lt;h2 id=&#34;数组与链表的优缺点和区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#数组与链表的优缺点和区别&#34;&gt;#&lt;/a&gt; 数组与链表的优缺点和区别&lt;/h2&gt;
&lt;p&gt;1、存取方式上，数组可以顺序存取或者随机存取，而链表只能顺序存取；　&lt;br&gt;
2、存储位置上，数组逻辑上相邻的元素在物理存储位置上也相邻，而链表不一定；　&lt;br&gt;
3、存储空间上，链表由于带有指针域，存储密度不如数组大；　&lt;br&gt;
4、按序号查找时，数组可以随机访问，时间复杂度为 O (1)，而链表不支持随机访问，平均需要 O (n)；　&lt;br&gt;
5、按值查找时，若数组无序，数组和链表时间复杂度均为 O (1)，但是当数组有序时，可以采用折半查找将时间复杂度降为 O (logn)；　&lt;br&gt;
6、插入和删除时，数组平均需要移动 n/2 个元素，而链表只需修改指针即可；　&lt;br&gt;
7、空间分配方面：&lt;br&gt;
　　数组在静态存储分配情形下，存储元素数量受限制，动态存储分配情形下，虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且如果内存中没有更大块连续存储空间将导致分配失败；&lt;br&gt;
　　链表存储的节点空间只在需要的时候申请分配，只要内存中有空间就可以分配，操作比较灵活高效；&lt;/p&gt;
&lt;h2 id=&#34;如何实现数组和-list-之间的转换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何实现数组和-list-之间的转换&#34;&gt;#&lt;/a&gt; 如何实现数组和 List 之间的转换？&lt;/h2&gt;
&lt;p&gt;List 转换成为数组：调用 ArrayList 的 toArray 方法。&lt;br&gt;
数组转换成为 List：调用 Arrays 的 asList 方法。&lt;/p&gt;
&lt;h2 id=&#34;4collection-和-collections的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#4collection-和-collections的区别&#34;&gt;#&lt;/a&gt; 4.Collection 和 Collections 的区别？&lt;/h2&gt;
&lt;p&gt;Collection 是接口，是 List 和 Set 的父接口&lt;br&gt;
 Collections 是工具类，提供了排序，混淆等等很多实用方法&lt;/p&gt;
&lt;h2 id=&#34;泛型的存在是用来解决什么问题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#泛型的存在是用来解决什么问题&#34;&gt;#&lt;/a&gt; 泛型的存在是用来解决什么问题。&lt;/h2&gt;
&lt;p&gt;泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率&lt;/p&gt;
&lt;h2 id=&#34;nio和-bio-的区别是啥谈谈-reactor-模型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#nio和-bio-的区别是啥谈谈-reactor-模型&#34;&gt;#&lt;/a&gt; nio 和 bio 的区别是啥，谈谈 reactor 模型。&lt;/h2&gt;
&lt;p&gt;IO (BIO) 是面向流的，NIO 是面向缓冲区的&lt;br&gt;
 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。&lt;br&gt;
NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。&lt;/p&gt;
&lt;h2 id=&#34;mysql-中-in-和-exists-区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mysql-中-in-和-exists-区别&#34;&gt;#&lt;/a&gt; mysql 中 in 和 exists 区别。&lt;/h2&gt;
&lt;p&gt;mysql 中的 in 语句是把外表和内表作 hash 连接，而 exists 语句是对外表作 loop 循环，每次 loop 循环再对内表进行查询。&lt;/p&gt;
&lt;h2 id=&#34;sleep-和-wait-有什么区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#sleep-和-wait-有什么区别&#34;&gt;#&lt;/a&gt; sleep () 和 wait () 有什么区别？&lt;/h2&gt;
&lt;p&gt;sleep () 和 wait () 都是线程暂停执行的方法。&lt;br&gt;
1、这两个方法来自不同的类分别是 Thread 和 Object，sleep 方法属于 Thread 类中的静态方法，wait 属于 Object 的成员方法。&lt;br&gt;
2、sleep () 是线程类（Thread）的方法，不涉及线程通信，调用时会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait () 是 Object 的方法，用于线程间的通信，调用时会放弃对象锁，进入等待队列，待调用 notify ()/notifyAll () 唤醒指定的线程或者所有线程，才进入对象锁定池准备获得对象锁进入运行状态。&lt;/p&gt;
&lt;h2 id=&#34;并行和并发有什么区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#并行和并发有什么区别&#34;&gt;#&lt;/a&gt; 并行和并发有什么区别？&lt;/h2&gt;
&lt;p&gt;并发：如果系统只有一个 cpu，把 CPU 运行时间划分成若干个时间段，再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。&lt;br&gt;
并行：当系统有一个以上 CPU 时，则线程的操作有可能非并发。当一个 CPU 执行一个线程时，另一个 CPU 可以执行另一个线程，两个线程互不抢占 CPU 资源，可以同时进行，这种方式我们称之为并行 (Parallel)。&lt;/p&gt;
&lt;h2 id=&#34;线程和进程的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#线程和进程的区别&#34;&gt;#&lt;/a&gt; . 线程和进程的区别？&lt;/h2&gt;
&lt;p&gt;进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是 cpu 调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。&lt;/p&gt;
&lt;h2 id=&#34;runnable-和-callable-有什么区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#runnable-和-callable-有什么区别&#34;&gt;#&lt;/a&gt; runnable 和 callable 有什么区别？&lt;/h2&gt;
&lt;p&gt;Runnable 接口中的 run () 方法的返回值是 void，它做的事情只是纯粹地去执行 run () 方法中的代码而已；&lt;br&gt;
Callable 接口中的 call () 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。&lt;/p&gt;
&lt;h2 id=&#34;osi七层模型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#osi七层模型&#34;&gt;#&lt;/a&gt; OSI 七层模型&lt;/h2&gt;
&lt;p&gt;物理层&lt;br&gt;
在 OSI 参考模型中，物理层（Physical Layer）是参考模型的最低层，也是 OSI 模型的第一层。&lt;br&gt;
物理层的主要功能是：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。&lt;br&gt;
数据链路层&lt;br&gt;
数据链路层（Data Link Layer）是 OSI 模型的第二层，负责建立和管理节点间的链路。该层的主要功能是：通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。&lt;br&gt;
网络层&lt;br&gt;
网络层（Network Layer）是 OSI 模型的第三层，它是 OSI 参考模型中最复杂的一层，也是通信子网的最高一层。它在下两层的基础上向资源子网提供服务。其主要任务是：通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。&lt;br&gt;
传输层&lt;br&gt;
 OSI 下 3 层的主要任务是数据通信，上 3 层的任务是数据处理。而传输层（Transport Layer）是 OSI 模型的第 4 层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。&lt;br&gt;
该层的主要任务是：向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。&lt;br&gt;
会话层&lt;br&gt;
会话层（Session Layer）是 OSI 模型的第 5 层，是用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层提供建立和使用连接的方法。&lt;br&gt;
表示层&lt;br&gt;
表示层（Presentation Layer）是 OSI 模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是 “处理用户信息的表示问题，如编码、数据格式转换和加密解密” 等。&lt;br&gt;
应用层&lt;br&gt;
应用层（Application Layer）是 OSI 参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。&lt;br&gt;
OSI7 层模型的小结&lt;br&gt;
在 7 层模型中，每一层都提供一个特殊的网络功能。从网络功能的角度观察：下面 4 层（物理层、数据链路层、网络层和传输层）主要提供数据传输和交换功能，即以节点到节点之间的通信为主；第 4 层作为上下两部分的桥梁，是整个网络体系结构中最关键的部分；而上 3 层（会话层、表示层和应用层）则以提供用户与应用程序之间的信息和数据处理功能为主。简言之，下 4 层主要完成通信子网的功能，上 3 层主要完成资源子网的功能。&lt;/p&gt;
&lt;h2 id=&#34;tcpip分层模型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#tcpip分层模型&#34;&gt;#&lt;/a&gt; TCP/IP 分层模型&lt;/h2&gt;
&lt;p&gt;第一层：网络接口层&lt;br&gt;
　　包括用于协作 IP 数据在已有网络介质上传输的协议。实际上 TCP/IP 标准并不定义与 ISO 数据链路层和物理层相对应的功能。相反，它定义像地址解析协议 (Address Resolution Protocol,ARP) 这样的协议，提供 TCP/IP 协议的数据结构和实际物理硬件之间的接口。&lt;br&gt;
　　第二层：网间层&lt;br&gt;
　　对应于 OSI 七层参考模型的网络层。本层包含 IP 协议、RIP 协议 (Routing Information Protocol，路由信息协议)，负责数据的包装、寻址和路由。同时还包含网间控制报文协议 (Internet Control Message Protocol,ICMP) 用来提供网络诊断信息。&lt;br&gt;
　　第三层：传输层&lt;br&gt;
　　对应于 OSI 七层参考模型的传输层，它提供两种端到端的通信服务。其中 TCP 协议 (Transmission Control Protocol) 提供可靠的数据流运输服务，UDP 协议 (Use Datagram Protocol) 提供不可靠的用户数据报服务。&lt;br&gt;
　　第四层：应用层&lt;br&gt;
　　对应于 OSI 七层参考模型的应用层和表达层。因特网的应用层协议包括 Finger、Whois、FTP (文件传输协议)、Gopher、HTTP (超文本传输协议)、Telent (远程终端协议)、SMTP (简单邮件传送协议)、IRC (因特网中继会话)、NNTP（网络新闻传输协议）等，这也是本书将要讨论的重点。&lt;/p&gt;
&lt;h2 id=&#34;arraylist和linkedlist的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#arraylist和linkedlist的区别&#34;&gt;#&lt;/a&gt; ArrayList 和 LinkedList 的区别&lt;/h2&gt;
&lt;p&gt;ArrayList 是数组结构，所以定位很快，但是插入和删除很慢&lt;br&gt;
 LinkedList 是双向链表结构，所以插入和删除很快，但是定位很慢&lt;/p&gt;
&lt;h2 id=&#34;equals和的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#equals和的区别&#34;&gt;#&lt;/a&gt; equals 和 == 的区别？&lt;/h2&gt;
&lt;p&gt;== 是判断两个变量或实例是不是指向同一个内存空间，equals 是判断两个变量或实例所指向的内存空间的值是不是相同&lt;br&gt;
 == 是指对内存地址进行比较 ， equals () 是对字符串的内容进行比较&lt;br&gt;
 == 指引用是否相同， equals () 指的是值是否相同&lt;/p&gt;
&lt;h2 id=&#34;try-里有一个return语句那么紧跟在这个try后的finally-里的code会不会被执行什么时候被执行在return前还是后&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#try-里有一个return语句那么紧跟在这个try后的finally-里的code会不会被执行什么时候被执行在return前还是后&#34;&gt;#&lt;/a&gt; try {} 里有一个 return 语句，那么紧跟在这个 try 后的 finally {} 里的 code 会不会被执行，什么时候被执行，在 return 前还是后？&lt;/h2&gt;
&lt;p&gt;try 里的 return 和 finally 里的 return 都会执行，但是当前方法只会采纳 finally 中 return 的值。无论 try、catch 块中执行怎样的代码，出现怎样的情况，异常处理的 finally 块总会被执行。&lt;/p&gt;
&lt;h2 id=&#34;for循环中的return-break-continue的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#for循环中的return-break-continue的区别&#34;&gt;#&lt;/a&gt; for 循环中的 return break continue 的区别？&lt;/h2&gt;
&lt;p&gt;执行 return 后，不仅结束了该循环，当前函数也结束了，后面的语句不再执行；break 会终止并跳出它所在的循环；continue 是跳出本次循环，进入下一次循环的入口处 执行下一次循环&lt;/p&gt;
&lt;h2 id=&#34;error和exception有什么区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#error和exception有什么区别&#34;&gt;#&lt;/a&gt; Error 和 Exception 有什么区别？&lt;/h2&gt;
&lt;p&gt;Error 和 Exception 都实现了 Throwable 接口&lt;br&gt;
 Error 指的是 JVM 层面的错误，比如内存不足 OutOfMemoryError&lt;br&gt;
Exception 指的是代码逻辑的异常，比如下标越界 OutOfIndexException&lt;/p&gt;
&lt;h2 id=&#34;tcp握手协议&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#tcp握手协议&#34;&gt;#&lt;/a&gt; TCP 握手协议&lt;/h2&gt;
&lt;p&gt;第一次握手：建立连接时，客户端发送 syn 包 (syn=j) 到服务器，并进入 SYN_SEND 状态，等待服务器确认；&lt;br&gt;
SYN：同步序列编号 (Synchronize Sequence Numbers)&lt;br&gt;
 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1）, 同时自己也发送一个 SYN 包（syn=k）, 即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；&lt;br&gt;
第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK (ack=k+1), 此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手.&lt;/p&gt;
&lt;h2 id=&#34;集合类都有哪些主要方法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#集合类都有哪些主要方法&#34;&gt;#&lt;/a&gt; 集合类都有哪些？主要方法？&lt;/h2&gt;
&lt;p&gt;常见的集合：ArrayList,LinkedList,HashSet,HashMap,TreeSet 等等&lt;br&gt;
常见方法：size ()、add ()、remove ()&lt;br&gt;
 String 常用的方法：length ()、valueOf ()、split ()、substring ()&lt;/p&gt;
&lt;h2 id=&#34;多线程有几种实现方法都是什么&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#多线程有几种实现方法都是什么&#34;&gt;#&lt;/a&gt; 多线程有几种实现方法，都是什么？&lt;/h2&gt;
&lt;p&gt;通常来讲，Java 创建一个线程有三种方式&lt;br&gt;
①　继承一个 Thread 类&lt;br&gt;
②　实现 Runnable 接口&lt;br&gt;
③　匿名内部类&lt;/p&gt;
&lt;h2 id=&#34;list-set-map的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#list-set-map的区别&#34;&gt;#&lt;/a&gt; List, Set, Map 的区别？&lt;/h2&gt;
&lt;p&gt;list 是最常用的 它其实就是一种可以自由改变长度的数组&lt;br&gt;
 set 和 list 基本的用法差不多 区别在于 set 里不能放相同的元素&lt;br&gt;
至于 map 这个和上边 2 个在用法上有很大差别 map 里储存的是键值对 可以根据键来值搜索值 键是唯一的 值可以重复… 学 Servlet 和 jsp 的时候 会有大量的 map 的应用&lt;/p&gt;
&lt;h2 id=&#34;和的区别-2&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#和的区别-2&#34;&gt;#&lt;/a&gt; &amp;amp; 和 &amp;amp;&amp;amp; 的区别？&lt;/h2&gt;
&lt;p&gt;&amp;amp; 有两个作用，分别是 位与 和 逻辑与&lt;br&gt;
 &amp;amp;&amp;amp; 就是逻辑与&lt;br&gt;
作为逻辑与， &amp;amp; 和 &amp;amp;&amp;amp; 分别表示长路与和短路与&lt;br&gt;
长路与 两侧，都会被运算&lt;br&gt;
短路与 只要第一个是 false，第二个就不进行运算了&lt;/p&gt;
&lt;h2 id=&#34;五个常见到的runtime-exception&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#五个常见到的runtime-exception&#34;&gt;#&lt;/a&gt; 五个常见到的 runtime exception。&lt;/h2&gt;
&lt;p&gt;NullPointerException 空指针异常&lt;br&gt;
 ArithmeticException 算术异常，比如除数为零&lt;br&gt;
 ClassCastException 类型转换异常&lt;br&gt;
 ConcurrentModificationException 同步修改异常，遍历一个集合的时候，删除集合的元素，就会抛出该异常&lt;br&gt;
 IndexOutOfBoundsException 数组下标越界异常&lt;br&gt;
 NegativeArraySizeException 为数组分配的空间是负数异常&lt;/p&gt;
&lt;h2 id=&#34;servlet的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#servlet的生命周期&#34;&gt;#&lt;/a&gt; servlet 的生命周期？&lt;/h2&gt;
&lt;p&gt;一个 Servlet 的生命周期由 实例化，初始化，提供服务，销毁，被回收 几个步骤组成&lt;/p&gt;
&lt;h2 id=&#34;string是最常使用的java类之一整理的了一些重要的string知识&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#string是最常使用的java类之一整理的了一些重要的string知识&#34;&gt;#&lt;/a&gt; String 是最常使用的 Java 类之一，整理的了一些重要的 String 知识&lt;/h2&gt;
&lt;h3 id=&#34;什么是string它是什么数据类型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是string它是什么数据类型&#34;&gt;#&lt;/a&gt; 什么是 String，它是什么数据类型？&lt;/h3&gt;
&lt;p&gt;String 是定义在 java.lang 包下的一个类。它不是基本数据类型。&lt;br&gt;
String 是不可变的，JVM 使用字符串池来存储所有的字符串对象。&lt;/p&gt;
&lt;h3 id=&#34;创建string对象的不同方式有哪些&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#创建string对象的不同方式有哪些&#34;&gt;#&lt;/a&gt; 创建 String 对象的不同方式有哪些？&lt;/h3&gt;
&lt;p&gt;和使用其他类一样通过 new 关键字来创建。&lt;br&gt;
使用这种方式时，JVM 创建字符串对象但不存储于字符串池。我们可以调用 intern () 方法将该字符串对象存储在字符串池，如果字符串池已经有了同样值的字符串，则返回引用。&lt;br&gt;
使用双引号直接创建。&lt;br&gt;
使用这种方式时，JVM 去字符串池找有没有值相等字符串，如果有，则返回找到的字符串引用。否则创建一个新的字符串对象并存储在字符串池。&lt;br&gt;
String str = new String(“abc”);&lt;br&gt;
String str1 = “abc”;&lt;/p&gt;
&lt;h3 id=&#34;string-类的常用方法都有那些&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#string-类的常用方法都有那些&#34;&gt;#&lt;/a&gt; String 类的常用方法都有那些？&lt;/h3&gt;
&lt;p&gt;indexOf ()：返回指定字符的索引。&lt;br&gt;
charAt ()：返回指定索引处的字符。&lt;br&gt;
replace ()：字符串替换。&lt;br&gt;
trim ()：去除字符串两端空白。&lt;br&gt;
split ()：分割字符串，返回一个分割后的字符串数组。&lt;br&gt;
getBytes ()：返回字符串的 byte 类型数组。&lt;br&gt;
length ()：返回字符串长度。&lt;br&gt;
toLowerCase ()：将字符串转成小写字母。&lt;br&gt;
toUpperCase ()：将字符串转成大写字符。&lt;br&gt;
substring ()：截取字符串。&lt;br&gt;
equals ()：字符串比较。&lt;/p&gt;
&lt;h3 id=&#34;如何让一个字符串变成小写或大写形式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何让一个字符串变成小写或大写形式&#34;&gt;#&lt;/a&gt; 如何让一个字符串变成小写或大写形式？&lt;/h3&gt;
&lt;p&gt;使用 toUpperCase 和 toLowerCase 方法让一个字符串变为 大写或小写。&lt;/p&gt;
&lt;h3 id=&#34;如何比较两个字符串&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何比较两个字符串&#34;&gt;#&lt;/a&gt; 如何比较两个字符串？&lt;/h3&gt;
&lt;p&gt;String 内部实现了 Comparable 接口，有两个比较方法：compareTo (String anotherString) 和 compareToIgnoreCase (String str)。&lt;br&gt;
compareTo(String anotherString)&lt;br&gt;
 与传入的 anotherString 字符串进行比较，如果小于传入的字符串返回负数，如果大于则返回证书。当两个字符串值相等时，返回 0. 此时 eqauls 方法会返回 true。&lt;br&gt;
equalsIgnoreCase(String str)&lt;br&gt;
 该方法与 compareTo 方法类似，区别只是内部利用了 Character.toUpperCase 等方法进行了大小写转换后进行比较。&lt;/p&gt;
&lt;h3 id=&#34;如何将string转换为char反过来呢&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何将string转换为char反过来呢&#34;&gt;#&lt;/a&gt; 如何将 String 转换为 char, 反过来呢？&lt;/h3&gt;
&lt;p&gt;这是一个误导题，String 是一系列字符，所有我们没法转换成一个单一的 char，但可以调用 toCharArray () 方法将字符串转成字符数组。&lt;br&gt;
String str = “Java interview”;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//string to char array
char[] chars = str.toCharArray();
System.out.println(chars.length);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如何将string转换为byte-array反过来呢&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何将string转换为byte-array反过来呢&#34;&gt;#&lt;/a&gt; 如何将 String 转换为 byte array, 反过来呢？&lt;/h3&gt;
&lt;p&gt;使用 String 的 getBytes () 方法将 String 转成 byte 数组，使用 String 的构造方法 new String (byte [] arr) 将 byte 数据转为 String。&lt;br&gt;
public class StringToByteArray {&lt;br&gt;
public static void main(String[] args) {&lt;br&gt;
String str = “PANKAJ”;&lt;br&gt;
byte[] byteArr = str.getBytes();&lt;br&gt;
// print the byte[] elements&lt;br&gt;
System.out.println(&amp;quot;String to byte array: &amp;quot; + Arrays.toString(byteArr));&lt;br&gt;
}&lt;br&gt;
}&lt;br&gt;
public class ByteArrayToString {&lt;br&gt;
public static void main(String[] args) {&lt;br&gt;
byte[] byteArray = { ‘P’, ‘A’, ‘N’, ‘K’, ‘A’, ‘J’ };&lt;br&gt;
byte[] byteArray1 = { 80, 65, 78, 75, 65, 74 };&lt;br&gt;
String str = new String(byteArray);&lt;br&gt;
String str1 = new String(byteArray1);&lt;br&gt;
System.out.println(str);&lt;br&gt;
System.out.println(str1);&lt;br&gt;
}&lt;br&gt;
}&lt;/p&gt;
&lt;div id=&#34;question8&#34;&gt;&lt;/div&gt;
&lt;h3 id=&#34;string-stringbufferstringbuilder的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#string-stringbufferstringbuilder的区别&#34;&gt;#&lt;/a&gt; String, StringBuffer，StringBuilder 的区别？&lt;/h3&gt;
&lt;p&gt;String 是不可变类，每当我们对 String 进行操作的时候，总是会创建新的字符串。操作 String 很耗资源，所以 Java 提供了两个工具类来操作 String - StringBuffer 和 StringBuilder。&lt;br&gt;
StringBuffer 和 StringBuilder 是可变类，StringBuffer 是线程安全的，StringBuilder 则不是线程安全的。所以在多线程对同一个字符串操作的时候，我们应该选择用 StringBuffer。由于不需要处理多线程的情况，StringBuilder 的效率比 StringBuffer 高。&lt;/p&gt;
&lt;h3 id=&#34;string是不可变的有什么好处&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#string是不可变的有什么好处&#34;&gt;#&lt;/a&gt; String 是不可变的有什么好处？&lt;/h3&gt;
&lt;p&gt;String 是不可变类有以下几个优点&lt;br&gt;
由于 String 是不可变类，所以在多线程中使用是安全的，我们不需要做任何其他同步操作。&lt;br&gt;
String 是不可变的，它的值也不能被改变，所以用来存储数据密码很安全。&lt;br&gt;
因为 java 字符串是不可变的，可以在 java 运行时节省大量 java 堆空间。因为不同的字符串变量可以引用池中的相同的字符串。如果字符串是可变得话，任何一个变量的值改变，就会反射到其他变量，那字符串池也就没有任何意义了。&lt;/p&gt;
&lt;h3 id=&#34;如何判断两个string是否相等&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#如何判断两个string是否相等&#34;&gt;#&lt;/a&gt; 如何判断两个 String 是否相等？&lt;/h3&gt;
&lt;p&gt;有两种方式判断字符串是否相等，使用 &amp;quot;&lt;mark&gt;“或者使用 equals 方法。当使用”&lt;/mark&gt;&amp;quot; 操作符时，不仅比较字符串的值，还会比较引用的内存地址。大多数情况下，我们只需要判断值是否相等，此时用 equals 方法比较即可。&lt;/p&gt;
&lt;h3 id=&#34;什么是字符串池&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是字符串池&#34;&gt;#&lt;/a&gt; 什么是字符串池？&lt;/h3&gt;
&lt;p&gt;顾名思义，字符串常量池就是用来存储字符串的。它存在于 Java 堆内存。&lt;br&gt;
一些 java 题中，可能会问一段代码中有几个字符串被创建，例如：&lt;br&gt;
String str = new String(“Cat”);&lt;br&gt;
 上面一行代码将会创建 1 或 2 个字符串。如果在字符串常量池中已经有一个字符串 “Cat”，那么就智慧创建一个 “Cat” 字符串。如果字符串常量池中没有 “Cat”，那么首先会在字符串池中创建，然后才在堆内存中创建，这种情况就会创建 2 个对象了。&lt;/p&gt;
&lt;h3 id=&#34;string的intern方法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#string的intern方法&#34;&gt;#&lt;/a&gt; String 的 intern () 方法&lt;/h3&gt;
&lt;p&gt;当 intern () 方法被调用，如果字符串池中含有一个字符串和当前调用方法的字符串 eqauls 相等，那么就会返回池中的字符串。如果池中没有的话，则首先将当前字符串加入到池中，然后返回引用。&lt;/p&gt;
&lt;h3 id=&#34;string是线程安全的吗&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#string是线程安全的吗&#34;&gt;#&lt;/a&gt; String 是线程安全的吗？&lt;/h3&gt;
&lt;p&gt;String 是不可变类，一旦创建了 String 对象，我们就无法改变它的值。因此，它是线程安全的，可以安全地用于多线程环境中。&lt;/p&gt;
&lt;h3 id=&#34;为什么我们在使用hashmap的时候总是用string做key&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#为什么我们在使用hashmap的时候总是用string做key&#34;&gt;#&lt;/a&gt; 为什么我们在使用 HashMap 的时候总是用 String 做 key？&lt;/h3&gt;
&lt;p&gt;因为字符串是不可变的，当创建字符串时，它的它的 hashcode 被缓存下来，不需要再次计算。因为 HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，所以相比于其他对象更快。这也是为什么我们平时都使用 String 作为 HashMap 对象。&lt;/p&gt;
&lt;h2 id=&#34;ssm&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ssm&#34;&gt;#&lt;/a&gt; SSM：&lt;/h2&gt;
&lt;p&gt;Spring+SpringMVC+Mybatis&lt;/p&gt;
&lt;h2 id=&#34;spring&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring&#34;&gt;#&lt;/a&gt; Spring&lt;/h2&gt;
&lt;h3 id=&#34;spring-在ssm中起什么作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-在ssm中起什么作用&#34;&gt;#&lt;/a&gt; Spring 在 ssm 中起什么作用？&lt;/h3&gt;
&lt;p&gt;Spring：轻量级框架&lt;br&gt;
作用：Bean 工厂，用来管理 Bean 的生命周期和框架集成。&lt;br&gt;
两大核心：&lt;br&gt;
①. IOC/DI (控制反转 / 依赖注入) ：把 dao 依赖注入到 service 层，service 层反转给 action 层，Spring 顶层容器为 BeanFactory。&lt;br&gt;
②. AOP：面向切面编程&lt;/p&gt;
&lt;h3 id=&#34;spring的事务&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring的事务&#34;&gt;#&lt;/a&gt; Spring 的事务？&lt;/h3&gt;
&lt;p&gt;编程式事务管理：编程方式管理事务，极大灵活性，难维护。&lt;br&gt;
声明式事务管理：可以将业务代码和事务管理分离，用注解和 xml 配置来管理事务。&lt;/p&gt;
&lt;h3 id=&#34;ioc-在项目中的作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ioc-在项目中的作用&#34;&gt;#&lt;/a&gt; IOC 在项目中的作用？&lt;/h3&gt;
&lt;p&gt;作用：Ioc 解决对象之间的依赖问题，把所有 Bean 的依赖关系通过配置文件或注解关联起来，降低了耦合度。&lt;/p&gt;
&lt;h3 id=&#34;spring的配置文件中的内容&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring的配置文件中的内容&#34;&gt;#&lt;/a&gt; Spring 的配置文件中的内容？&lt;/h3&gt;
&lt;p&gt;开启事务注解驱动&lt;br&gt;
事务管理器&lt;br&gt;
开启注解功能，并配置扫描包&lt;br&gt;
配置数据库&lt;br&gt;
配置 SQL 会话工厂，别名，映射文件&lt;br&gt;
不用编写 Dao 层的实现类&lt;/p&gt;
&lt;h3 id=&#34;spring下的注解&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring下的注解&#34;&gt;#&lt;/a&gt; Spring 下的注解？&lt;/h3&gt;
&lt;p&gt;注册：@Controller @Service @Component&lt;br&gt;
 注入：@Autowired @Resource&lt;br&gt;
 请求地址：@RequestMapping&lt;br&gt;
 返回具体数据类型而非跳转：@ResponseBody&lt;/p&gt;
&lt;h3 id=&#34;spring-di-的三种方式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-di-的三种方式&#34;&gt;#&lt;/a&gt; Spring DI 的三种方式？&lt;/h3&gt;
&lt;p&gt;构造器注入：通过构造方法初始化&lt;br&gt;
&lt;constructor-arg index=&#34;0&#34; type=&#34;java.lang.String&#34; value=&#34;宝马&#34;&gt;&lt;/constructor-arg&gt;&lt;br&gt;
setter 方法注入：通过 setter 方法初始化&lt;br&gt;
&lt;property name=&#34;id&#34; value=&#34;1111&#34;&gt;&lt;/property&gt;&lt;br&gt;
接口注入&lt;/p&gt;
&lt;h3 id=&#34;spring主要使用了什么模式&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring主要使用了什么模式&#34;&gt;#&lt;/a&gt; Spring 主要使用了什么模式？&lt;/h3&gt;
&lt;p&gt;工厂模式：每个 Bean 的创建通过方法&lt;br&gt;
单例模式：默认的每个 Bean 的作用域都是单例&lt;br&gt;
代理模式：关于 Aop 的实现通过代理模式&lt;/p&gt;
&lt;h3 id=&#34;iocaop的实现原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#iocaop的实现原理&#34;&gt;#&lt;/a&gt; IOC，AOP 的实现原理？&lt;/h3&gt;
&lt;p&gt;IOC：通过反射机制生成对象注入&lt;br&gt;
 AOP：动态代理&lt;/p&gt;
&lt;h3 id=&#34;什么是ioc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是ioc&#34;&gt;#&lt;/a&gt; . 什么是 IOC？&lt;/h3&gt;
&lt;p&gt;IOC： Inversion of control 反转控制。 比如以前创建一个对象，需要自己主动 new 一个对象，通过 IOC，对象的创建交由 Spring 框架 创建，开发人员直接使用已经创建好的对象。&lt;/p&gt;
&lt;h3 id=&#34;什么是di&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是di&#34;&gt;#&lt;/a&gt; 什么是 DI？&lt;/h3&gt;
&lt;p&gt;DI： Dependency Injection 依赖注入。 通过 IOC 创建对象的时候，可以注入字符串甚至其他对象。 比如 DAO 就会注入 session factory.&lt;br&gt;
 通常 IOC 和 DI 是紧密结合，一起使用的&lt;/p&gt;
&lt;h3 id=&#34;什么是aop&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是aop&#34;&gt;#&lt;/a&gt; 什么是 AOP？&lt;/h3&gt;
&lt;p&gt;AOP: 面向切面编程。&lt;br&gt;
把功能划分为核心业务功能和其他的周边辅助功能，比如日志，性能统计，事务等等。 其他的周边辅助功能可以都看作切面功能。核心功能和切面功能分别独立开发，通过面向切面编程，可以有机的把核心业务功能和切面功能根据需求结合在一起。 比如增加操作可以和事务切面结合在一起，查询操作可以和性能统计切面结合在一起。&lt;br&gt;
在配置方面，要配置切面，切点，并且通过 aspect:config 把切面和切点结合起来&lt;/p&gt;
&lt;h2 id=&#34;springmvc&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#springmvc&#34;&gt;#&lt;/a&gt; SpringMvc&lt;/h2&gt;
&lt;h3 id=&#34;springmvc-的控制器是不是单例模式如果是有什么问题怎么解决&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#springmvc-的控制器是不是单例模式如果是有什么问题怎么解决&#34;&gt;#&lt;/a&gt; SpringMvc 的控制器是不是单例模式，如果是，有什么问题，怎么解决？&lt;/h3&gt;
&lt;p&gt;问题：单例模式，在多线程访问时有线程安全问题&lt;br&gt;
解决方法：不要用同步，在控制器里面不能写字段&lt;/p&gt;
&lt;h3 id=&#34;springmvc-中控制器的注解&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#springmvc-中控制器的注解&#34;&gt;#&lt;/a&gt; SpringMvc 中控制器的注解？&lt;/h3&gt;
&lt;p&gt;@Controller：该注解表明该类扮演控制器的角色&lt;/p&gt;
&lt;h3 id=&#34;requestmapping-注解用在类上的作用&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#requestmapping-注解用在类上的作用&#34;&gt;#&lt;/a&gt; @RequestMapping 注解用在类上的作用？&lt;/h3&gt;
&lt;p&gt;作用：用来映射一个 URL 到一个类或者一个特定的处理方法上&lt;/p&gt;
&lt;h3 id=&#34;前台多个参数这些参数都是一个对象快速得到对象&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#前台多个参数这些参数都是一个对象快速得到对象&#34;&gt;#&lt;/a&gt; 前台多个参数，这些参数都是一个对象，快速得到对象？&lt;/h3&gt;
&lt;p&gt;方法：直接在方法中声明这个对象，SpringMvc 就自动把属性赋值到这个对象里面&lt;/p&gt;
&lt;h3 id=&#34;springmvc中函数的返回值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#springmvc中函数的返回值&#34;&gt;#&lt;/a&gt; SpringMvc 中函数的返回值？&lt;/h3&gt;
&lt;p&gt;String，ModelAndView，List，Set 等&lt;br&gt;
一般 String，Ajax 请求，返回一个 List 集合&lt;/p&gt;
&lt;h3 id=&#34;springmvc中的转发和重定向&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#springmvc中的转发和重定向&#34;&gt;#&lt;/a&gt; SpringMvc 中的转发和重定向？&lt;/h3&gt;
&lt;p&gt;转发： return：“hello”&lt;br&gt;
 重定向 ：return：“redirect:hello.jsp”&lt;br&gt;
 通过 JackSon 框架把 java 里面对象直接转换成 js 可识别的 json 对象，具体步骤如下：&lt;br&gt;
加入 JackSon.jar&lt;br&gt;
 在配置文件中配置 json 的映射&lt;br&gt;
在接受 Ajax 方法里面直接返回 Object，list 等，方法前面需要加上注解 @ResponseBody&lt;/p&gt;
&lt;h3 id=&#34;springmvc的工作流程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#springmvc的工作流程&#34;&gt;#&lt;/a&gt; SpringMvc 的工作流程&lt;/h3&gt;
&lt;p&gt;浏览器→发送请求→前端控制器（DispatcherServlet）→请求→处理器映射器 (HandlerMapping)→返回处理器执行链→前端控制器（DispatcherServlet）→发送处理器执行链→处理器适配器 (HandlerAdatper)→执行→处理器 (Handler)→ModelAndView→处理器适配器 (HandlerAdatper)→modelandview→前端控制器（DispatcherServlet）→modelandview→视图解析器→view→前端控制器（DispatcherServlet）→model→视图 (view)→前端控制器（DispatcherServlet）→响应→浏览器&lt;/p&gt;
&lt;h3 id=&#34;springmvc的工作原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#springmvc的工作原理&#34;&gt;#&lt;/a&gt; SpringMVC 的工作原理？&lt;/h3&gt;
&lt;p&gt;①　用户向服务器发送请求，请求被 springMVC 前端控制器 DispatchServlet 捕获；&lt;br&gt;
②　DispatcherServle 对请求 URL 进行解析，得到请求资源标识符（URL），然后根据该 URL 调用 HandlerMapping (处理器映射) 将请求映射到处理器 HandlerExcutionChain；&lt;br&gt;
③　DispatchServlet 根据获得 Handler 选择一个合适的 HandlerAdapter 适配器处理；&lt;br&gt;
④　Handler 对数据处理完成以后将返回一个 ModelAndView 对象给 DisPatchServlet；&lt;br&gt;
⑤　DispatcherSevlet 通过 ViewResolver（试图解析器）将逻辑视图转化为真正的视图 View；&lt;br&gt;
DispatcherServle 通过 model 解析出 ModelAndView () 中的参数进行解析最终展现出完整的 view 并返&lt;/p&gt;
&lt;h3 id=&#34;struts2-和-springmvc的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#struts2-和-springmvc的区别&#34;&gt;#&lt;/a&gt; Struts2 和 SpringMvc 的区别？&lt;/h3&gt;
&lt;p&gt;入口不同：&lt;br&gt;
Struts2：filter 过滤器&lt;br&gt;
 SpringMvc：一个 Servlet 即前端控制器&lt;/p&gt;
&lt;p&gt;开发方式不同：&lt;br&gt;
Struts2：基于类开发，传递参数通过类的属性，只能设置为多例&lt;br&gt;
 SpringMvc：基于方法开发 (一个 url 对应一个方法)，请求参数传递到方法形参，可以为单例也可以为多例 (建议单例)&lt;/p&gt;
&lt;p&gt;请求方式不同：&lt;br&gt;
Struts2：值栈村塾请求和响应的数据，通过 OGNL 存取数据&lt;br&gt;
 SpringMvc：通过参数解析器将 request 请求内容解析，给方法形参赋值，将数据和视图封装成 ModelAndView 对象，最后又将 ModelAndView 中的模型数据通过 request 域传输到页面，jsp 视图解析器默认使用的是 jstl。&lt;/p&gt;
&lt;h2 id=&#34;mybatis&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mybatis&#34;&gt;#&lt;/a&gt; Mybatis&lt;/h2&gt;
&lt;h3 id=&#34;ibatis和mybatis&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#ibatis和mybatis&#34;&gt;#&lt;/a&gt; Ibatis 和 Mybatis？&lt;/h3&gt;
&lt;p&gt;Ibatis：2010 年，apache 的 Ibatis 框架停止更新，并移交给了 google 团队，同时更名为 MyBatis。从 2010 年后 Ibatis 在没更新过，彻底变成了一个孤儿框架。一个没人维护的框架注定被 mybatis 拍在沙滩上。&lt;br&gt;
Mybatis：Ibatis 的升级版本。&lt;/p&gt;
&lt;h3 id=&#34;什么是mybatis的接口绑定有什么好处&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么是mybatis的接口绑定有什么好处&#34;&gt;#&lt;/a&gt; 什么是 Mybatis 的接口绑定，有什么好处？&lt;/h3&gt;
&lt;p&gt;Mybatis 实现了 DAO 接口与 xml 映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。&lt;/p&gt;
&lt;h3 id=&#34;什么情况用注解什么情况用xml绑定&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#什么情况用注解什么情况用xml绑定&#34;&gt;#&lt;/a&gt; 什么情况用注解，什么情况用 xml 绑定？&lt;/h3&gt;
&lt;p&gt;注解使用情况：Sql 语句简单时&lt;br&gt;
 xml 绑定使用情况：xml 绑定 (@RequestMap 用来绑定 xml 文件)&lt;/p&gt;
&lt;h3 id=&#34;mybatis在核心处理类叫什么&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mybatis在核心处理类叫什么&#34;&gt;#&lt;/a&gt; Mybatis 在核心处理类叫什么？&lt;/h3&gt;
&lt;p&gt;SqlSession&lt;/p&gt;
&lt;h3 id=&#34;查询表名和返回实体bean对象不一致如何处理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#查询表名和返回实体bean对象不一致如何处理&#34;&gt;#&lt;/a&gt; 查询表名和返回实体 Bean 对象不一致，如何处理？&lt;/h3&gt;
&lt;p&gt;映射键值对即可&lt;br&gt;
&lt;result column=&#34;title&#34; property=&#34;title&#34; javaType=&#34;java.lang.String&#34;/&gt;&lt;br&gt;
column：数据库中表的列名&lt;br&gt;
 property：实体 Bean 中的属性名&lt;/p&gt;
&lt;h3 id=&#34;mybatis的好处&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mybatis的好处&#34;&gt;#&lt;/a&gt; Mybatis 的好处？&lt;/h3&gt;
&lt;p&gt;把 Sql 语句从 Java 中独立出来。&lt;br&gt;
封装了底层的 JDBC，API 的调用，并且能够将结果集自动转换成 JavaBean 对象，简化了 Java 数据库编程的重复工作。&lt;br&gt;
自己编写 Sql 语句，更加的灵活。&lt;br&gt;
入参无需用对象封装（或者 map 封装）, 使用 @Param 注解&lt;/p&gt;
&lt;h3 id=&#34;mybatis配置一对多&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mybatis配置一对多&#34;&gt;#&lt;/a&gt; Mybatis 配置一对多？&lt;/h3&gt;
&lt;collection property=&#34;topicComment&#34; column=&#34;id&#34; ofType=&#34;com.tmf.bbs.pojo.Comment&#34; select=&#34;selectComment&#34; /&gt;
property：属性名
column：共同列
ofType：集合中元素的类型
select：要连接的查询
&lt;h3 id=&#34;mybatis配置一对一&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mybatis配置一对一&#34;&gt;#&lt;/a&gt; Mybatis 配置一对一？&lt;/h3&gt;
&lt;association property=&#34;topicType&#34; select=&#34;selectType&#34; column=&#34;topics_type_id&#34; javaType=&#34;com.tmf.bbs.pojo.Type&#34;/&gt;
property：属性名
select：要连接的查询
column：共同列
javaType：集合中元素的类型
&lt;h3 id=&#34;和-的区别&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#和-的区别&#34;&gt;#&lt;/a&gt; ${} 和 #{} 的区别？&lt;/h3&gt;
&lt;p&gt;${}： 简 单 字 符 串 替 换 ， 把 {}：简单字符串替换，把：简单字符串替换，把 {} 直接替换成变量的值，不做任何转换，这种是取值以后再去编译 SQL 语句。&lt;br&gt;
#{}：预编译处理，sql 中的 #{} 替换成？，补全预编译语句，有效的防止 Sql 语句注入，这种取值是编译好 SQL 语句再取值。&lt;br&gt;
总结：一般用 #{} 来进行列的代替&lt;/p&gt;
&lt;h3 id=&#34;获取上一次自动生成的主键值&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#获取上一次自动生成的主键值&#34;&gt;#&lt;/a&gt; 获取上一次自动生成的主键值？&lt;/h3&gt;
&lt;p&gt;select last _insert_id()&lt;/p&gt;
&lt;h3 id=&#34;mybatis如何分页分页原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mybatis如何分页分页原理&#34;&gt;#&lt;/a&gt; Mybatis 如何分页，分页原理？&lt;/h3&gt;
&lt;p&gt;RowBounds 对象分页&lt;br&gt;
在 Sql 内直接书写，带有物理分页&lt;/p&gt;
&lt;h3 id=&#34;mybatis工作原理&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#mybatis工作原理&#34;&gt;#&lt;/a&gt; Mybatis 工作原理？&lt;/h3&gt;
&lt;p&gt;通过 SqlSessionFactoryBuilder 从 mybatis-config.xml 配置文件中构建出 SqlSessionFactory。&lt;br&gt;
SqlSessionFactory 开启一个 SqlSession，通过 SqlSession 实例获得 Mapper 对象并且运行 Mapper 映射的 Sql 语句。&lt;br&gt;
完成数据库的 CRUD 操作和事务提交，关闭 SqlSession。&lt;/p&gt;
&lt;h2 id=&#34;状态和转换详解七态&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#状态和转换详解七态&#34;&gt;#&lt;/a&gt; 状态和转换详解 (七态)&lt;/h2&gt;
&lt;p&gt;操作系统之进程的状态和转换详解 (七态)&lt;/p&gt;
&lt;h3 id=&#34;三态模型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#三态模型&#34;&gt;#&lt;/a&gt; 三态模型&lt;/h3&gt;
&lt;p&gt;1. 运行态 (running): 占有处理器正在运行&lt;br&gt;
 2. 就绪态 (ready): 具备运行条件，等待系统分配处理器以便运行&lt;br&gt;
 3. 等待态 (blocked): 不具备运行条件，正在等待某个事件的完成&lt;br&gt;
运行态 —→等待态：等待使用资源；如等待外设传输；等待人工干预。&lt;br&gt;
等待态 —→就绪态：资源得到满足；如外设传输结束；人工干预完成。&lt;br&gt;
运行态 —→就绪态：运行时间片到；出现有更高优先权进程。&lt;br&gt;
就绪态 —→运行态：CPU 空闲时选择一个就绪进程。&lt;/p&gt;
&lt;h3 id=&#34;五态模型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#五态模型&#34;&gt;#&lt;/a&gt; 五态模型&lt;/h3&gt;
&lt;p&gt;建态（new）和终止态（exit ）&lt;br&gt;
NULL—→新建态：执行一个程序，创建一个子进程。&lt;br&gt;
新建态 —→就绪态：当操作系统完成了进程创建的必要操作，并且当前系统的性能和虚拟内存的容量均允许。&lt;br&gt;
运行态 —→终止态：当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结。&lt;br&gt;
终止态 —→NULL：完成善后操作。&lt;br&gt;
就绪态 —→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。&lt;br&gt;
等待态 —→终止态：未在状态转换图中显示，但某些操作系统允许父进程终结子进程。&lt;/p&gt;
&lt;h3 id=&#34;七态模型&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#七态模型&#34;&gt;#&lt;/a&gt; 七态模型&lt;/h3&gt;
&lt;p&gt;挂起就绪态（ready,suspend）&lt;br&gt;
挂起就绪态表明了进程具备运行条件但目前在二级存储器中，只有当它被对换到主存才能被调度执行&lt;br&gt;
挂起等待态（blocked,suspend）挂起等待态则表明了进程正在等待某一个事件且在二级存储器中。&lt;br&gt;
等待态 —→挂起等待态：如果当前不存在就绪进程，那么至少有一个等待态进程将被对换出去成为挂起等待态；操作系统根据当前资源状况和性能要求，可以决定把等待态进程对换出去成为挂起等待态。&lt;br&gt;
挂起等待态 —→挂起就绪态：引起进程等待的事件发生之后，相应的挂起等待态进程将转换为挂起就绪态。&lt;br&gt;
挂起就绪态 —→就绪态：当内存中没有就绪态进程，或者挂起就绪态进程具有比就绪态进程更高的优先级，系统将把挂起就绪态进程转换成就绪态。&lt;br&gt;
就绪态 —→挂起就绪态：操作系统根据当前资源状况和性能要求，也可以决定把就绪态进程对换出去成为挂起就绪态。&lt;br&gt;
挂起等待态 —→等待态：当一个进程等待一个事件时，原则上不需要把它调入内存。但是在下面一种情况下，这一状态变化是可能的。当一个进程退出后，主存已经有了一大块自由空间，而某个挂起等待态进程具有较高的优先级并且操作系统已经得知导致它阻塞的事件即将结束，此时便发生了这一状态变化。&lt;br&gt;
运行态 —→挂起就绪态：当一个具有较高优先级的挂起等待态进程的等待事件结束后，它需要抢占 CPU，，而此时主存空间不够，从而可能导致正在运行的进程转化为挂起就绪态。另外处于运行态的进程也可以自己挂起自己。&lt;br&gt;
新建态 —→挂起就绪态：考虑到系统当前资源状况和性能要求，可以决定新建的进程将被对换出去成为挂起就绪态。&lt;/p&gt;
&lt;h2 id=&#34;进程的挂起&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#进程的挂起&#34;&gt;#&lt;/a&gt; 进程的挂起&lt;/h2&gt;
&lt;p&gt;到目前为止，我们或多或少总是假设所有的进程都在内存中。事实上，可能出现这样一些情况，例如由于进程的不断创建，系统的资源已经不能满足进程运行的要求，这个时候就必须把某些进程挂起（suspend），对换到磁盘镜像区中，暂时不参与进程调度，起到平滑系统操作负荷的目的。&lt;/p&gt;
&lt;h3 id=&#34;引起进程挂起的原因是多样的主要有&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#引起进程挂起的原因是多样的主要有&#34;&gt;#&lt;/a&gt; 引起进程挂起的原因是多样的，主要有：&lt;/h3&gt;
&lt;p&gt;1. 系统中的进程均处于等待状态，处理器空闲，此时需要把一些阻塞进程对换出去，以腾出足够的内存装入就绪进程运行。&lt;br&gt;
2. 进程竞争资源，导致系统资源不足，负荷过重，此时需要挂起部分进程以调整系统负荷，保证系统的实时性或让系统正常运行。&lt;br&gt;
3. 把一些定期执行的进程（如审计程序、监控程序、记账程序）对换出去，以减轻系统负荷。&lt;br&gt;
4. 用户要求挂起自己的进程，以便根据中间执行情况和中间结果进行某些调试、检查和改正。&lt;br&gt;
5. 父进程要求挂起自己的后代进程，以进行某些检查和改正。&lt;br&gt;
6. 操作系统需要挂起某些进程，检查运行中资源使用情况，以改善系统性能；或当系统出现故障或某些功能受到破坏时，需要挂起某些进程以排除故障。&lt;/p&gt;
&lt;h3 id=&#34;一个挂起进程具有如下特征&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#一个挂起进程具有如下特征&#34;&gt;#&lt;/a&gt; 一个挂起进程具有如下特征：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;该进程不能立即被执行。&lt;/li&gt;
&lt;li&gt;挂起进程可能会等待一个事件，但所等待的事件是独立于挂起条件的，事件结束并不能导致进程具备执行条件。&lt;/li&gt;
&lt;li&gt;进程进入挂起状态是由于操作系统、父进程或进程本身阻止它的运行。&lt;/li&gt;
&lt;li&gt;结束进程挂起状态的命令只能通过操作系统或父进程发出。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;加密算法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#加密算法&#34;&gt;#&lt;/a&gt; 加密算法&lt;/h2&gt;
&lt;p&gt;BASE64 严格地说，属于编码格式，而非加密算法&lt;br&gt;
 MD5 (Message Digest algorithm 5，信息摘要算法)&lt;br&gt;
 SHA (Secure Hash Algorithm，安全散列算法)&lt;br&gt;
 HMAC (Hash Message Authentication Code，散列消息鉴别码)&lt;/p&gt;
&lt;h3 id=&#34;base64&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#base64&#34;&gt;#&lt;/a&gt; BASE64&lt;/h3&gt;
&lt;p&gt;Base64 是网络上最常见的用于传输 8Bit=1 字节代码的编码方式之一&lt;/p&gt;
</content>
        <updated>2021-01-17T10:21:37.380Z</updated>
    </entry>
    <entry>
        <id>http://example.com/2021/01/08/hello-world/</id>
        <title>Hello World</title>
        <link rel="alternate" href="http://example.com/2021/01/08/hello-world/"/>
        <content type="html">&lt;p&gt;Welcome to &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvLw==&#34;&gt;Hexo&lt;/span&gt;! This is your very first post. Check &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv&#34;&gt;documentation&lt;/span&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=&#34;&gt;troubleshooting&lt;/span&gt; or you can ask me on &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==&#34;&gt;GitHub&lt;/span&gt;.&lt;/p&gt;
&lt;h2 id=&#34;quick-start&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#quick-start&#34;&gt;#&lt;/a&gt; Quick Start&lt;/h2&gt;
&lt;h3 id=&#34;create-a-new-post&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#create-a-new-post&#34;&gt;#&lt;/a&gt; Create a new post&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo new &lt;span class=&#34;token string&#34;&gt;&#34;My New Post&#34;&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s&#34;&gt;Writing&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;run-server&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#run-server&#34;&gt;#&lt;/a&gt; Run server&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo server&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=&#34;&gt;Server&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;generate-static-files&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#generate-static-files&#34;&gt;#&lt;/a&gt; Generate static files&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo generate&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s&#34;&gt;Generating&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;deploy-to-remote-sites&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#deploy-to-remote-sites&#34;&gt;#&lt;/a&gt; Deploy to remote sites&lt;/h3&gt;
&lt;figure class=&#34;highlight bash&#34;&gt;&lt;figcaption data-lang=&#34;bash&#34;&gt;&lt;span&gt;h&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;$ hexo deploy&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;More info: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s&#34;&gt;Deployment&lt;/span&gt;&lt;/p&gt;
</content>
        <updated>2021-01-08T13:46:11.333Z</updated>
    </entry>
</feed>
